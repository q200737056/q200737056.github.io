<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty框架入门教程</title>
      <link href="/post/2019/4/8/"/>
      <url>/post/2019/4/8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="一、传统socket编程"><a href="#一、传统socket编程" class="headerlink" title="一、传统socket编程"></a>一、传统socket编程</h3><p><strong>阻塞IO</strong><br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305110955033-209972831.png" class="lozad"></p><p>在任何时候都可能有大量的线程处于休眠状态，只是等待输入或者输出数据就绪，这可能算是一种资源浪费。<br>需要为每个线程的调用栈都分配内存，其默认值大小区间为 64 KB 到 1 MB，具体取决于操作系统。<br>即使 Java 虚拟机（JVM）在物理上可以支持非常大数量的线程，但是远在到达该极限之前，上下文切换所带来的开销就会带来麻烦。</p><p><strong>NIO</strong><br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305112301600-1800444605.png" class="lozad"><br>class java.nio.channels.Selector 是Java 的非阻塞 I/O 实现的关键。它使用了事件通知 API以确定在一组非阻塞套接字中有哪些已经就绪能够进行 I/O 相关的操作。因为可以在任何的时间检查任意的读操作或者写操作的完成状态，所以如图 1-2 所示，一个单一的线程便可以处理多个并发的连接。</p><h3 id="二、Netty核心组件"><a href="#二、Netty核心组件" class="headerlink" title="二、Netty核心组件"></a>二、Netty核心组件</h3><p><strong>Channel</strong></p><p>它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执<br>行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作<br>目前，可以把 Channel 看作是传入（入站）或者传出（出站）数据的载体。因此，它可以<br>被打开或者被关闭，连接或者断开连接。</p><p><strong>回调</strong></p><p>一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。这使得后者可以在适当的时候调用前者。回调在广泛的编程场景中都有应用，而且也是在操作完成后通知相关方最常见的方式之一<br>Netty 在内部使用了回调来处理事件；当一个回调被触发时，相关的事件可以被一个 interfaceChannelHandler 的实现处理。代码清单 1-2 展示了一个例子：当一个新的连接已经被建立时，<br>ChannelHandler 的 channelActive()回调方法将会被调用，并将打印出一条信息<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305113908038-1307892950.png" class="lozad"></p><p><strong>Future</strong></p><p>Future 提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。</p><p>JDK 预置了 interface java.util.concurrent.Future，但是其所提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。这是非常繁琐的，所以 Netty提供了它自己的实现——ChannelFuture，用于在执行异步操作的时候使用。</p><p>ChannelFuture提供了几种额外的方法，这些方法使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，将会在对应的操作完成时被调用。</p><p>简而言之 ，由ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。</p><p>每个 Netty 的出站 I/O 操作都将返回一个 ChannelFuture；也就是说，它们都不会阻塞。正如我们前面所提到过的一样，Netty 完全是异步和事件驱动的。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305114425617-1289110722.png" class="lozad"></p><p><strong>事件和 ChannelHandler</strong></p><p>Netty 使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经<br>发生的事件来触发适当的动作。这些动作可能是：</p><ul><li>记录日志；</li><li>数据转换；</li><li>流控制；</li><li>应用程序逻辑</li></ul><p>每个事件都可以被分发给 ChannelHandler 类中的某个用户实现的方法。这是一个很好的将事件驱动范式直接转换为应用程序构件块的例子。</p><p>Netty 的 ChannelHandler 为处理器提供了基本的抽象，如图 1-3 所示的那些<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305115155102-1832475869.png" class="lozad"></p><h3 id="三、服务端和客服端"><a href="#三、服务端和客服端" class="headerlink" title="三、服务端和客服端"></a>三、服务端和客服端</h3><p><strong>服务端核心流程</strong><br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305154124368-1174309774.png" class="lozad"><br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305154033642-1825955764.png" class="lozad"></p><p>EchoServerHandler 实现了业务逻辑；<br>main()方法引导了服务器；</p><p>引导过程中所需要的步骤如下：</p><ul><li>创建一个 ServerBootstrap 的实例以引导和绑定服务器；</li><li>创建并分配一个 NioEventLoopGroup 实例以进行事件的处理，如接受新连接以及读/<br>写数据；</li><li>指定服务器绑定的本地的 InetSocketAddress；</li><li>使用一个 EchoServerHandler 的实例初始化每一个新的 Channel；</li><li>调用 ServerBootstrap.bind()方法以绑定服务器</li></ul><p><strong>客户端核心流程</strong></p><p>Echo 客户端将会：</p><ul><li>连接到服务器；</li><li>发送一个或者多个消息；</li><li>对于每个消息，等待并接收从服务器发回的相同的消息；</li><li>关闭连接。</li></ul><p><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305162511491-1319044955.png" class="lozad"><br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305162542636-741235571.png" class="lozad"></p><p><strong>流程</strong></p><ul><li>为初始化客户端，创建了一个 Bootstrap 实例；</li><li>为进行事件处理分配了一个 NioEventLoopGroup 实例，其中事件处理包括创建新的连接以及处理入站和出站数据；</li><li>为服务器连接创建了一个 InetSocketAddress 实例；</li><li>当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；</li><li>在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；</li></ul><h3 id="四、Netty的组件和设计"><a href="#四、Netty的组件和设计" class="headerlink" title="四、Netty的组件和设计"></a>四、Netty的组件和设计</h3><h5 id="1-Channel、EventLoop-和-ChannelFuture"><a href="#1-Channel、EventLoop-和-ChannelFuture" class="headerlink" title="1. Channel、EventLoop 和 ChannelFuture"></a>1. Channel、EventLoop 和 ChannelFuture</h5><p>Channel—Socket；<br>EventLoop—控制流、多线程处理、并发；<br>ChannelFuture—异步通知</p><p><strong>Channel 接口</strong></p><p>基本的 I/O 操作（bind()、connect()、read()和 write()）依赖于底层网络传输所提供的原语。<br>Netty 的 Channel 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p><p><strong>EventLoop 接口</strong></p><p>EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。<br>图 3-1在高层次上说明了 Channel、EventLoop、Thread 以及 EventLoopGroup 之间的关系。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305164036264-2094385727.png" class="lozad"></p><p>这些关系是：</p><ul><li>一个 EventLoopGroup 包含一个或者多个 EventLoop；</li><li>一个 EventLoop 在它的生命周期内只和一个 Thread 绑定；<br>所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</li><li>一个 Channel 在它的生命周期内只注册于一个 EventLoop；</li><li>一个 EventLoop 可能会被分配给一个或多个 Channel</li></ul><p><strong>ChannelFuture 接口</strong></p><p>Netty 中所有的 I/O 操作都是异步的。因为一个操作可能不会立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了ChannelFuture 接口，其 addListener()方法注册了一个 ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。</p><h5 id="2-ChannelHandler-和-ChannelPipeline"><a href="#2-ChannelHandler-和-ChannelPipeline" class="headerlink" title="2. ChannelHandler 和 ChannelPipeline"></a>2. ChannelHandler 和 ChannelPipeline</h5><p><strong>ChannelHandler 接口</strong></p><p>从应用程序开发人员的角度来看，Netty 的主要组件是 ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。</p><p><strong>ChannelPipeline 接口</strong></p><p>ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的 API。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。<br>ChannelHandler 安装到 ChannelPipeline 中的过程如下所示：</p><ul><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中</li><li>当 ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在 ChannelPipeline 中安装一组自定义的 ChannelHandler；</li><li>ChannelInitializer 将它自己从 ChannelPipeline 中移除。</li></ul><p>图 3-3 说明了一个 Netty 应用程序中入站和出站数据流之间的区别。从一个客户端应用程序的角度来看，如果事件的运动方向是从客户端到服务器端，那么我们称这些事件为出站的，反之则称为入站的。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190305165012382-796213306.png" class="lozad"></p><p><strong>编码器和解码器</strong></p><ul><li>当你通过 Netty 发送或者接收一个消息的时候，就将会发生一次数据转换。入站消息会被解码；也就是说，从字节转换为另一种格式，通常是一个 Java 对象。</li><li>如果是出站消息，则会发生相反方向的转换：它将从它的当前格式被编码为字节。这两种方向的转换的原因很简单：网络数据总是一系列的字节。</li></ul><p><strong>抽象类 SimpleChannelInboundHandler</strong></p><p>最常见的情况是，你的应用程序会利用一个 ChannelHandler 来接收解码消息，并对该数据应用业务逻辑。<br>要创建一个这样的 ChannelHandler，你只需要扩展基类 SimpleChannelInboundHandler，其中 T 是你要处理的消息的 Java 类型 。</p><h3 id="五、传输"><a href="#五、传输" class="headerlink" title="五、传输"></a>五、传输</h3><p>流经网络的数据总是具有相同的类型：字节。这些字节是如何流动的主要取决于我们所说的网络传输—一个帮助我们抽象底层数据传输机制的概念。</p><p>ChannelHandler 的典型用途包括：</p><ul><li>将数据从一种格式转换为另一种格式；</li><li>提供异常的通知；</li><li>提供 Channel 变为活动的或者非活动的通知；</li><li>提供当 Channel 注册到 EventLoop 或者从 EventLoop 注销时的通知；</li><li>提供有关用户自定义事件的通知</li></ul><p><strong>ByteBuf</strong></p><p>网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。<br>Netty 的 ByteBuffer 替代品是 ByteBuf，一个强大的实现，既解决了 JDK API 的局限性，又为网络应用程序的开发者提供了更好的 API。</p><p>下面是一些 ByteBuf API 的优点：</p><ul><li>它可以被用户自定义的缓冲区类型扩展；</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝；</li><li>容量可以按需增长（类似于 JDK 的 StringBuilder）；</li><li>在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法；</li><li>读和写使用了不同的索引；</li><li>支持方法的链式调用；</li><li>支持引用计数；</li><li>支持池化</li></ul><p>如何工作</p><p>ByteBuf 维护了两个不同的索引：一个用于读取，一个用于写入。当你从 ByteBuf 读取时，它的readerIndex 将会被递增已经被读取的字节数。同样地，当你写入 ByteBuf 时，它的writerIndex 也会被递增。</p><p><strong>ByteBuf 的使用模式</strong></p><h5 id="1-堆缓冲区"><a href="#1-堆缓冲区" class="headerlink" title="1. 堆缓冲区"></a>1. 堆缓冲区</h5><p>最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。这种方式，如代码清单5-1 所示，非常适合于有遗留的数据需要处理的情况。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306101821595-901860518.png" class="lozad"></p><h5 id="2-直接缓冲区"><a href="#2-直接缓冲区" class="headerlink" title="2. 直接缓冲区"></a>2. 直接缓冲区</h5><p>直接缓冲区是另外一种 ByteBuf 模式。我们期望用于对象创建的内存分配永远都来自于堆中，但这并不是必须的——NIO 在 JDK 1.4 中引入的 ByteBuffer 类允许 JVM 实现通过本地调用来分配内存。这主要是为了避免在每次调用本地 I/O 操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。<br>直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。如果你正在处理遗留代码，你也可能会遇到另外一个缺点：因为数据不是在堆上，所以你不得不进行一次复制，如代码清单 5-2 所示。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306102223559-1630091903.png" class="lozad"></p><h5 id="3-复合缓冲区"><a href="#3-复合缓冲区" class="headerlink" title="3. 复合缓冲区"></a>3. 复合缓冲区</h5><p>第三种也是最后一种模式使用的是复合缓冲区，它为多个 ByteBuf 提供一个聚合视图。在这里你可以根据需要添加或者删除 ByteBuf 实例，这是一个 JDK 的 ByteBuffer 实现完全缺失的特性。<br>Netty 通过一个 ByteBuf 子类CompositeByteBuf实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。<br>代码清单 5-3 展示了如何通过使用 JDK 的 ByteBuffer 来实现这一需求。创建了一个包含两个 ByteBuffer 的数组用来保存这些消息组件，同时创建了第三个 ByteBuffer 用来保存所有这些数据的副本。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306102541695-1755282306.png" class="lozad"></p><p>分配和复制操作，以及伴随着对数组管理的需要，使得这个版本的实现效率低下而且笨拙。代码清单 5-4 展示了一个使用了 CompositeByteBuf 的版本<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306102705488-1146974635.png" class="lozad"></p><p>CompositeByteBuf 可能不支持访问其支撑数组，因此访问 CompositeByteBuf 中的数据类似于（访问）直接缓冲区的模式，如代码清单 5-5 所示。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306102811168-2129345696.png" class="lozad"></p><h5 id="4-Unpooled-缓冲区"><a href="#4-Unpooled-缓冲区" class="headerlink" title="4. Unpooled 缓冲区"></a>4. Unpooled 缓冲区</h5><p>可能某些情况下，你未能获取一个到 ByteBufAllocator 的引用。对于这种情况，Netty 提供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf实例。表 5-8 列举了这些中最重要的方法。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306103631250-1455172534.png" class="lozad"></p><h3 id="六、ChannelHandler和ChannelPipeline"><a href="#六、ChannelHandler和ChannelPipeline" class="headerlink" title="六、ChannelHandler和ChannelPipeline"></a>六、ChannelHandler和ChannelPipeline</h3><p><strong>Channel 的生命周期</strong></p><p>Interface Channel 定义了一组和 ChannelInboundHandler API 密切相关的简单但功能强大的状态模型<br>ChannelUnregistered Channel 已经被创建，但还未注册到 EventLoop<br>ChannelRegistered Channel 已经被注册到了 EventLoop<br>ChannelActive Channel 处于活动状态（已经连接到它的远程节点）。它现在可以接收和发送数据了<br>ChannelInactive Channel 没有连接到远程节点<br>Channel 的正常生命周期如图 6-1 所示。当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给 ChannelPipeline 中的 ChannelHandler，其可以随后对它们做出响应</p><p><strong>ChannelHandler 的生命周期</strong></p><p>表 6-2 中列出了 interface ChannelHandler 定义的生命周期操作，在 ChannelHandler被添加到 ChannelPipeline 中或者被从 ChannelPipeline 中移除时会调用这些操作。这些方法中的每一个都接受一个 ChannelHandlerContext 参数。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306104440342-1764054310.png" class="lozad"></p><p>Netty 定义了下面两个重要的 ChannelHandler 子接口：<br>ChannelInboundHandler——处理入站数据以及各种状态变化；<br>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作。</p><p><strong>ChannelInboundHandler 接口</strong><br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306104801303-1189532527.png" class="lozad"></p><p>当某个 ChannelInboundHandler 的实现重写 channelRead()方法时，它将负责显式地释放与池化的 ByteBuf 实例相关的内存。Netty 为此提供了一个实用方法 ReferenceCountUtil.release()，如代码清单 6-1 所示。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306104928374-394704367.png" class="lozad"></p><p>Netty 将使用 WARN 级别的日志消息记录未释放的资源，使得可以非常简单地在代码中发现违规的实例。但是以这种方式管理资源可能很繁琐。一个更加简单的方式是使用SimpleChannelInboundHandler。代码清单 6-2 是代码清单 6-1 的一个变体，说明了这一点</p><p>** ChannelOutboundHandler 接口**</p><p>出站操作和数据将由 ChannelOutboundHandler处理。它的方法将被 Channel、ChannelPipeline 以及 ChannelHandlerContext调用<br>ChannelOutboundHandler 的一个强大的功能是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求。例如，如果到远程节点的写入被暂停了，那么你可以推迟冲刷操作并在稍后继续<br>表6-4显示了所有由ChannelOutboundHandler本身所定义的方法（忽略了那些从ChannelHandler 继承的方法）。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306105643303-847840836.png" class="lozad"></p><p><strong>ChannelHandler 适配器</strong></p><p>你可以使用 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter类作为自己的 ChannelHandler 的起始点。这两个适配器分别提供了 ChannelInboundHandler和ChannelOutboundHandler 的基本实现。</p><p>ChannelHandlerAdapter 还提供了实用方法 isSharable()。如果其对应的实现被标注为 Sharable，那么这个方法将返回 true，表示它可以被添加到多个 ChannelPipeline中</p><p><strong>ChannelPipeline 接口</strong></p><p>ChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改<br>ChannelPipeline 的布局。<br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306112040978-1309816402.png" class="lozad"><br><img alt data-src="https://img2018.cnblogs.com/blog/751560/201903/751560-20190306112154503-561143095.png" class="lozad"></p><blockquote><p><strong>转载自天尘·云烟博客 <a href="https://www.cnblogs.com/sky-chen/p/10497166.html" target="_blank" rel="noopener">netty入门（一）</a></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> NetworkFrame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO使用教程</title>
      <link href="/post/2019/3/6/"/>
      <url>/post/2019/3/6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>文中示例代码：<a href="https://github.com/q200737056/Java-Course" target="_blank" rel="noopener">https://github.com/q200737056/Java-Course</a></p></blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>Java NIO是java 1.4之后新出的一套IO接口，这里的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。NIO中的N可以理解为Non-blocking（非阻塞）。</p><p>同步（Sync）vs 异步（Async）</p><ul><li>同步，发出一个功能调用时，在没有得到结果之前，不会执行后续操作。</li><li>异步，发出一个功能调用时，会立即返回，不管有没有得到结果。继续执行后续操作。一般通过状态、通知和回调来通知调用者。</li></ul><p>阻塞 vs 非阻塞</p><ul><li>阻塞，调用结果返回之前，当前线程会被阻塞。只有在得到结果之后才会返回。</li><li>非阻塞，不能立刻得到调用结果时，当前线程不会被阻塞。</li></ul><p>其实同步异步与阻塞非阻塞区别是关注的角度不同，同步和异步关注调用后是否等待结果返回。而阻塞和非阻塞关注的是调用时当前的线程是否阻塞。</p><p>NIO vs IO</p><ul><li>IO是面向流的，而NIO是面向缓冲区的。</li><li>IO的各种流都是阻塞的。这意味着一个线程一旦调用了read(),write()方法，那么该线程就被阻塞住了；NIO的非阻塞模式使得线程可以通过channel来读数据，并且返回当前已有的数据，或者返回空的（可能没有数据）。这样一来线程不会被阻塞住，它可以继续向下执行。</li></ul><p>NIO包含3个核心的组件</p><ul><li>Channel通道。如FileChannel，SocketChannel，ServerSocketChannel，DatagramChannel。</li><li>Buffer缓冲区。如ByteBuffer，CharBuffer，IntBuffer，MappedByteBuffer。</li><li>Selector多路复用器。</li></ul><h4 id="二、Channel，Buffer，Selector"><a href="#二、Channel，Buffer，Selector" class="headerlink" title="二、Channel，Buffer，Selector"></a>二、Channel，Buffer，Selector</h4><p>Channel通道和流非常相似，主要有以下几点区别</p><ul><li>通道可以读也可以写，流一般来说是单向的（只能读或者写）。</li><li>通道可以异步读写。</li><li>通道总是基于缓冲区Buffer来读写。</li></ul><p>通过一个FileChannel的例子来了解如何使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"d:/test.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = file.getChannel();</span><br><span class="line"><span class="comment">//开辟一块48字节的缓冲区</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="comment">//从通道中写入到缓冲区</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">    <span class="keyword">while</span>(bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//写模式转读模式</span></span><br><span class="line">      buf.flip();</span><br><span class="line">      <span class="comment">//如果position与limit上限之间有元素，则一个一个读取</span></span><br><span class="line">      <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//清空数据，准备下次写入，实际上只是重置了位置标识</span></span><br><span class="line">      buf.clear();</span><br><span class="line">     <span class="comment">//继续读</span></span><br><span class="line">      bytesRead = inChannel.read(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    file.close();</span><br></pre></td></tr></table></figure><p>Buffer最重要的3个属性</p><ul><li>capacity容量</li><li>position位置</li><li>limit上限</li></ul><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-3146b5ace9ec7045.png" class="lozad"><br><strong>容量（Capacity）</strong><br>作为一块内存，buffer有一个固定的大小，叫做capacity容量。也就是最多只能写入容量值得字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据。</p><p><strong>位置（Position）</strong><br>当写入数据到Buffer的时候需要中一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1.<br>当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。</p><p><strong>上限（Limit）</strong><br>在写模式，limit的含义是我们所能写入的最大数据量。它等同于buffer的容量。<br>一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。<br>数据读取的上限时buffer中已有的数据，也就是limit的位置（原position所指的位置）。</p><p><strong>Buffer主要的几个方法介绍</strong><br><strong>flip()</strong><br>flip方法可以把Buffer从写模式切换到读模式。会把position归零，并设置limit为之前的position的值。<br><strong>rewind()</strong><br>rewind方法将position设置为0，limit保持不变，这样我们可以重复读取buffer中的数据。<br><strong>clear() 与compact()</strong><br>clear方法会重置position为0，limit为capacity，也就是把整个Buffer清空，为下次写入做好准备。实际上Buffer中数据并没有清空，我们只是把标记重置了。<br>compact方法保留未读数据，即重置position为limit-原来的position，limit为capacity，清空了已读部分。<br><strong>mark()与reset()</strong><br>通过mark方法可以标记当前的position，通过reset来恢复到原来的position位置。</p><p>Selector多路复用器实现了可以用单线程来处理多个channel。对高并发来说大大减少了对线程的开销。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-aaefc45b7155700d.png" class="lozad"></p><p><strong>如何使用Selector</strong></p><ol><li><p>创建Selector。<code>Selector selector = Selector.open();</code></p></li><li><p>注册Channel到Selector上。Channel必须是非阻塞的。FileChannel不能切换为非阻塞模式，所以不适用。<code>SocketChannel channel= SocketChannel.open(); channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</code><br>register方法第二个参数为关注集合。</p><ul><li>SelectionKey.OP_CONNECT(1 &lt;&lt; 3)连接就绪状态</li><li>SelectionKey.OP_ACCEPT(1 &lt;&lt; 4)可连接就绪状态</li><li>SelectionKey.OP_READ(1 &lt;&lt; 0)读就绪状态</li><li>SelectionKey.OP_WRITE(1 &lt;&lt; 2)写就绪状态</li></ul><p>我们发现这些状态值都使用了位运算，所以想监听多个状态时，可使用位或运算结合多个常量。<code>SelectionKey.OP_READ | SelectionKey.OP_WRITE</code>。取出来的时候可以按位与运算。<code>int val = key.interestOps();int op_accept  = val &amp; SelectionKey.OP_ACCEPT;</code></p><p>register重载方法还有第3个参数。可以给SelectionKey附加一个Object对象，这样做一方面可以方便我们识别某个特定的channel，同时也增加了channel相关的附加信息。<code>channel.register(selector, SelectionKey.OP_READ, obj);</code>，也可以调用SelectionKey对象的attach方法添加。<code>key.attach(theObject);</code>，取出附加信息<code>Object obj= key.attachment();</code></p></li><li><p>调用selector.select()阻塞等待，select方法底层实现是一个轮询，跟操作系统有关。select方法会返回所有处于就绪状态的channel。</p></li><li><p>返回了有channel就绪之后，获取SelectionKey集合。<code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</code>，遍历SelectionKey集合，根据各个就绪状态，进行相应的处理。</p></li></ol><h4 id="三、NIO套接字通道简单示例"><a href="#三、NIO套接字通道简单示例" class="headerlink" title="三、NIO套接字通道简单示例"></a>三、NIO套接字通道简单示例</h4><p><strong>服务端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;  </span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">//开出一块1024字节的缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">    <span class="keyword">private</span> CharsetDecoder decoder = Charset.forName(<span class="string">"GB2312"</span>).newDecoder();  </span><br><span class="line">    <span class="keyword">private</span> CharsetEncoder encoder = Charset.forName(<span class="string">"GB2312"</span>).newEncoder();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        selector = <span class="keyword">this</span>.getSelector(port);  </span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Selector <span class="title">getSelector</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//获得一个ServerSocketChannel通道  </span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置通道为非阻塞</span></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>); </span><br><span class="line">        <span class="comment">// 绑定端口 </span></span><br><span class="line">        server.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建多路复用器</span></span><br><span class="line">        Selector sel = Selector.open();  </span><br><span class="line">        <span class="comment">//将该通道绑定到Selector，并为该通道注册SelectionKey.OP_ACCEPT事件(可连    接事件监听)  </span></span><br><span class="line">        <span class="comment">//当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。  </span></span><br><span class="line">        server.register(sel, SelectionKey.OP_ACCEPT);  </span><br><span class="line">        <span class="keyword">return</span> sel;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"服务端启动成功！"</span>); </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//当注册的事件到达时，方法返回；否则,该方法会一直阻塞 </span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获得selectedKey集合的迭代器</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();  </span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;  </span><br><span class="line">                    SelectionKey key =  iter.next();</span><br><span class="line">                    <span class="comment">// 必须手工移除,以防重复处理</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                    </span><br><span class="line">                    process(key);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 处理事件  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 接收请求  </span></span><br><span class="line">            ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="comment">// 获得和客户端连接的通道 </span></span><br><span class="line">            SocketChannel channel = server.accept();  </span><br><span class="line">            <span class="comment">//设置非阻塞模式  </span></span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读就绪状态。</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 读信息</span></span><br><span class="line">           <span class="comment">// 服务器可读取消息，得到事件发生的SocketChannel通道 </span></span><br><span class="line">            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//从Channel写到Buffer</span></span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);  </span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//将Buffer从写模式切换到读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">                <span class="comment">//解码</span></span><br><span class="line">                CharBuffer charBuffer = decoder.decode(buffer);  </span><br><span class="line">                name = charBuffer.toString();  </span><br><span class="line">                System.out.println(<span class="string">"收到客户端信息："</span>+name);</span><br><span class="line">                <span class="comment">//给通道设置写就绪</span></span><br><span class="line">                SelectionKey sKey = channel.register(selector,  </span><br><span class="line">                        SelectionKey.OP_WRITE);  </span><br><span class="line">                sKey.attach(name);<span class="comment">//附加name数据  </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                channel.close();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//清空缓冲区</span></span><br><span class="line">            buffer.clear();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123; <span class="comment">// 写事件  </span></span><br><span class="line">            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//获取附加的name</span></span><br><span class="line">            String name = (String) key.attachment();</span><br><span class="line">            System.out.println(<span class="string">"向客户端发送消息："</span>+<span class="string">"Hello! "</span> + name);</span><br><span class="line">            <span class="comment">// 编码</span></span><br><span class="line">            ByteBuffer block = encoder.encode(CharBuffer.wrap(<span class="string">"Hello! "</span> + name));  </span><br><span class="line">              </span><br><span class="line">            <span class="comment">//从Buffer读取数据到Channel</span></span><br><span class="line">            channel.write(block);  </span><br><span class="line">            <span class="comment">//关闭客户端通道</span></span><br><span class="line">            channel.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="comment">//单线程 管理多个SocketChannel通道</span></span><br><span class="line">        HelloServer server = <span class="keyword">new</span> HelloServer(<span class="number">8888</span>);  </span><br><span class="line">        server.listen();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress ip = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>);</span><br><span class="line">    <span class="keyword">private</span> CharsetDecoder decoder = Charset.forName(<span class="string">"GB2312"</span>).newDecoder();  </span><br><span class="line">    <span class="keyword">private</span> CharsetEncoder encoder = Charset.forName(<span class="string">"GB2312"</span>).newEncoder();  </span><br><span class="line">    </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> String name;  </span><br><span class="line">     <span class="keyword">private</span> String msg = <span class="string">""</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();  </span><br><span class="line">                <span class="comment">//打开SocketChannel通道  </span></span><br><span class="line">                SocketChannel client = SocketChannel.open();  </span><br><span class="line">                <span class="comment">//设置为非阻塞模式  </span></span><br><span class="line">                client.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line">                <span class="comment">// 创建多路复用器  </span></span><br><span class="line">                Selector selector = Selector.open();  </span><br><span class="line">                <span class="comment">//注册连接就绪状态</span></span><br><span class="line">                client.register(selector, SelectionKey.OP_CONNECT);  </span><br><span class="line">                <span class="comment">//去连接  </span></span><br><span class="line">                client.connect(ip);  </span><br><span class="line">                <span class="comment">//创建读取的缓冲区 </span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">               </span><br><span class="line">                _FOR: <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </span><br><span class="line">                    selector.select(); </span><br><span class="line">                    <span class="comment">// 获得selectedKey集合的迭代器</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();  </span><br><span class="line">  </span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;  </span><br><span class="line">                        SelectionKey key =  iter.next();</span><br><span class="line">                        <span class="comment">// 必须手工移除,以防重复处理</span></span><br><span class="line">                        iter.remove();  </span><br><span class="line">                        <span class="keyword">if</span> (key.isConnectable()) &#123; <span class="comment">// 连接事件监听   </span></span><br><span class="line">                            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                            <span class="comment">// 如果正在连接，则完成连接</span></span><br><span class="line">                            <span class="keyword">if</span> (channel.isConnectionPending())  </span><br><span class="line">                                channel.finishConnect();</span><br><span class="line">                            <span class="comment">//向服务器发送数据</span></span><br><span class="line">                            System.out.println(<span class="string">"向服务端发送消息："</span>+name);</span><br><span class="line">                            channel.write(encoder.encode(CharBuffer.wrap(name))); </span><br><span class="line">                            <span class="comment">//在和服务端连接成功之后，给通道设置读就绪状态</span></span><br><span class="line">                            channel.register(selector, SelectionKey.OP_READ);  </span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;  <span class="comment">// 可读事件监听  </span></span><br><span class="line">                            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                            <span class="comment">//从Channel写到Buffer</span></span><br><span class="line">                            <span class="keyword">int</span> count = channel.read(buffer);  </span><br><span class="line">                            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                                <span class="comment">//将Buffer从写模式切换到读模式</span></span><br><span class="line">                                buffer.flip();  </span><br><span class="line">                                CharBuffer charBuffer = decoder.decode(buffer);  </span><br><span class="line">                                msg = charBuffer.toString(); </span><br><span class="line">                                System.out.println(<span class="string">"收到服务端信息："</span>+msg);</span><br><span class="line">                                <span class="comment">//清空整个缓存,compact()方法只会清除已经读过的数据</span></span><br><span class="line">                                buffer.clear();  </span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(name+<span class="string">"没数据可读，关闭客户端"</span>);</span><br><span class="line">                                client.close();  </span><br><span class="line">                                <span class="keyword">break</span> _FOR;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; </span><br><span class="line">                    </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">double</span> last = (System.currentTimeMillis() - start) * <span class="number">1.0</span> / <span class="number">1000</span>;  </span><br><span class="line">                System.out.println(name+<span class="string">"使用时间 :"</span> + last + <span class="string">"s."</span>);  </span><br><span class="line">                msg = <span class="string">""</span>;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    </span><br><span class="line">        HelloClient cli = <span class="keyword">new</span> HelloClient();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"开启客户端"</span>+index);</span><br><span class="line">            <span class="keyword">new</span> Thread(cli.new Message(<span class="string">"client["</span> + index + <span class="string">"]"</span>).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、异步文件通道"><a href="#四、异步文件通道" class="headerlink" title="四、异步文件通道"></a>四、异步文件通道</h4><p>Java7中新增了AsynchronousFileChannel异步文件通道，使得数据可以进行异步读写。<br><strong>以下简单例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">AIOTest test  = <span class="keyword">new</span> AIOTest();</span><br><span class="line">test.writeTest(<span class="string">"d:/1.txt"</span>);</span><br><span class="line">test.readTest(<span class="string">"d:/1.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readTest</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Path path = Paths.get(filename);</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);</span><br><span class="line"><span class="comment">//是否操作完成</span></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">buffer.get(data);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTest</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Path path = Paths.get(filename);</span><br><span class="line">                <span class="keyword">if</span>(!Files.exists(path))&#123;</span><br><span class="line">    Files.createFile(path);</span><br><span class="line">&#125;</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//是否操作完成</span></span><br><span class="line">buffer.put(<span class="string">"112345678"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.write(buffer, position);</span><br><span class="line">buffer.clear();</span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line">System.out.println(<span class="string">"Write done"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="关注课间指针，更多精彩等你" data-src="https://upload-images.jianshu.io/upload_images/18796269-251d336cb6e7ddc9.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP和IOC实现原理</title>
      <link href="/post/2019/4/2/"/>
      <url>/post/2019/4/2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1.AOP"></a>1.AOP</h4><p>AOP（面向切面）是一种编程范式，提供从另一个角度来考虑程序结构以完善面向对象编程（OOP）。<br>AOP为开发者提供了一种描述横切关注点的机制，并能够自动将横切关注点织入到面向对象的软件系统中，从而实现了横切关注点的模块化。<br>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任，例如事务处理、日志管理、权限控制等，封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p><p><strong>使用AOP的好处</strong></p><ul><li>降低模块的耦合度</li><li>使系统容易扩展</li><li>提高代码复用性</li></ul><p><strong>AOP的基本概念</strong></p><ul><li>连接点（JoinPoint）：需要在程序中插入横切关注点的点，连接点可能是在类初始化、方法调用、字段调用或处理异常等等。Spring中只支持方法执行连接点。</li><li>切入点（Pointcut）：一组相关连接点的集合。</li><li>通知（Advice）：在连接点上执行的行为，增强提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括前置增强（before advice）、后置增强 (after advice)、环绕增强 （around advice）。</li><li>切面（Aspect）：通知和切入点的结合。</li><li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程。</li><li>代理（Proxy）：通过代理方式来对目标对象应用切面。AOP代理可以用JDK动态代理或CGLIB代理实现。</li><li>目标对象（Target）：需要被织入关注点的对象。即被代理的对象。</li></ul><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-73cc3e80c1a96413.jpg" class="lozad"></p><p>实现AOP的主要设计模式就是动态代理。<br>Spring的动态代理有两种：一是JDK的动态代理；另一个是cglib动态代理。</p><p><strong>JDK动态代理模拟</strong><br>JDK动态代理的两个核心接口(类)分别是InvocationHandler和Proxy。注意：只能代理接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 目标对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeHandler</span><span class="params">(Object targetObject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="comment">//关联的这个实现类的方法被调用时将被执行  </span></span><br><span class="line">    <span class="comment">/*InvocationHandler接口的方法，proxy表示代理，method表示原对象被调用的方法，      </span></span><br><span class="line"><span class="comment">        args表示方法的参数*/</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        Object ret=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"方法之前："</span>+System.currentTimeMillis());    </span><br><span class="line">            <span class="comment">//调用目标方法  </span></span><br><span class="line">            ret=method.invoke(targetObject, args);  </span><br><span class="line">            System.out.println(<span class="string">"方法之后："</span>+System.currentTimeMillis());  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            System.out.println(<span class="string">"error"</span>);  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TimeHandler 类实现了InvocationHandler接口。实现核心方法invoke，共有3个参数。第一个参数 生成的代理类实例，第二个参数 目标对象的方法，第三个参数 方法的参数值数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">proxyOne</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] clz,InvocationHandler handler)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T)Proxy.newProxyInstance(loader, clz, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyUtil 类简单封装了一下Proxy.newProxyInstance()方法。该方法也有3个参数。第一个参数产生代理对象的类加载器，第二个参数目标对象的接口数组，第三个参数就是实现InvocationHandler接口的类实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String userId, String userName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManagerImpl</span> <span class="keyword">implements</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String userId, String userName)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"addUser(id:"</span>+userId+<span class="string">",name:"</span>+userName+<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         UserManager um=<span class="keyword">new</span> UserManagerImpl(); </span><br><span class="line">         LogHandler log =<span class="keyword">new</span> LogHandler(um); </span><br><span class="line"> um=ProxyUtil.proxyOne(um.getClass().getClassLoader(), </span><br><span class="line">     um.getClass().getInterfaces(), log);</span><br><span class="line">     </span><br><span class="line">   TimeHandler time = <span class="keyword">new</span> TimeHandler(um);</span><br><span class="line">   um=ProxyUtil.proxyOne(um.getClass().getClassLoader(), </span><br><span class="line">     um.getClass().getInterfaces(), time);</span><br><span class="line">     </span><br><span class="line">     um.addUser(<span class="string">"1111"</span>, <span class="string">"张三"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了演示需要，这边又增加了一个LogHandler，跟TimeHandler代码一样。</p><p><strong>CGLIB动态代理模拟</strong><br>CGLIB动态代理的两个核心接口(类)分别是MethodInterceptor和Enhancer。是不是跟JDK动态代理很相似，用法也差不多。但CGLIB可以代理类和接口。注意：不能代理final类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object target;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeInterceptor</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">Object[] args, MethodProxy invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"方法之前："</span>+System.currentTimeMillis());</span><br><span class="line">Object ret = invocation.invoke(target, args); </span><br><span class="line">System.out.println(<span class="string">"方法之后："</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intercept方法4个参数。1.生成的代理类实例。2.被代理对象的方法引用。3.方法参数值数组。4.代理类对方法的代理引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> </span>&#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">proxyOne</span><span class="params">(Class&lt;?&gt; clz,MethodInterceptor interceptor)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T)Enhancer.create(clz, interceptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Enhancer类是CGLib中的字节码增强器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String userId, String userName)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"addUser(id:"</span>+userId+<span class="string">",name:"</span>+userName+<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">UserManage um = <span class="keyword">new</span> UserManage();</span><br><span class="line">TimeInterceptor time = <span class="keyword">new</span> TimeInterceptor(um);</span><br><span class="line">um = ProxyUtil.proxyOne(um.getClass(), time);</span><br><span class="line">um.addUser(<span class="string">"111"</span>, <span class="string">"老王"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2.IOC"></a>2.IOC</h4><p>IOC（控制反转）就是依赖倒置原则的一种代码设计思路。就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。<br>Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是工厂模式。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-94421d32a8342c99.png" class="lozad"><br><strong>使用IOC的好处</strong></p><ul><li>集中管理，实现类的可配置和易管理。</li><li>降低了类与类之间的耦合度。</li></ul><p><strong>简单模拟IOC</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String id)</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//容器，用来存放注入的Bean  </span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; container = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析xml文件，通过反射将配置的bean放到container中  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">        SAXBuilder sb = <span class="keyword">new</span> SAXBuilder(); </span><br><span class="line"></span><br><span class="line">        Document doc </span><br><span class="line">        =sb.build(ClassPathXmlApplicationContext.class.getResource(<span class="string">"/"</span>+fileName));</span><br><span class="line">       </span><br><span class="line">        Element root = doc.getRootElement();  </span><br><span class="line">        List&lt;Element&gt; list = XPath.selectNodes(root, <span class="string">"/beans/bean"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;              </span><br><span class="line">           Element bean = list.get(i);  </span><br><span class="line">           String id = bean.getAttributeValue(<span class="string">"id"</span>);  </span><br><span class="line">           String clazz = bean.getAttributeValue(<span class="string">"class"</span>);  </span><br><span class="line">           Object o = Class.forName(clazz).newInstance();  </span><br><span class="line">           container.put(id, o);  </span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String id)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> container.get(id);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要导入 jdom.jar包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.ioc.People"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"chicken"</span> <span class="attr">class</span>=<span class="string">"com.ioc.Chicken"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.ioc.Dog"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"汪汪"</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"鸡你很美"</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"小明-23岁"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载配置文件  </span></span><br><span class="line">        BeanFactory f = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);  </span><br><span class="line"></span><br><span class="line">        Object os = f.getBean(<span class="string">"dog"</span>);  </span><br><span class="line">        Animal dog = (Animal)os;  </span><br><span class="line">        dog.say();  </span><br><span class="line"></span><br><span class="line">        Object op = f.getBean(<span class="string">"chicken"</span>);  </span><br><span class="line">        Animal chicken = (Animal)op;  </span><br><span class="line">        chicken.say();  </span><br><span class="line"></span><br><span class="line">        Object p = f.getBean(<span class="string">"people"</span>);  </span><br><span class="line">        People people= (Animal)p;  </span><br><span class="line">        people.info();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong><br><a href="https://www.iteye.com/blog/jinnianshilongnian-1474325" target="_blank" rel="noopener">我对AOP的理解</a><br><a href="https://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="noopener">源码解读Spring IOC原理</a><br><img alt="关注课间指针，更多精彩等你" data-src="https://upload-images.jianshu.io/upload_images/18796269-251d336cb6e7ddc9.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程与并发-进阶篇</title>
      <link href="/post/2019/3/5/"/>
      <url>/post/2019/3/5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p><a href="https://www.jianshu.com/p/96d20b6b64a1" target="_blank" rel="noopener">Java多线程与并发-基础篇</a></p></blockquote><h4 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1.线程池"></a>1.线程池</h4><p>首先简单来介绍一下Executor。Executor 框架是 jdk1.5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。Executor 框架包括：Executor，Executors，ExecutorService，ThreadPoolExecutor，CompletionService，Future，Callable 等。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-43ca156a75179533.png" class="lozad"></p><p>Executors 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。</p><ul><li>newCachedThreadPool()：创建一个可缓存的线程池。先查看池中有没有以前建立的线程，如果有，就使用；如果没有，就建一个新的线程加入池中。能重复使用的线程，必须是闲置有效期内的池中线程，缺省 timeout 是 60s,超过这个时长，线程实例将被终止及移出池。</li><li>newFixedThreadPool(int nThreads)：创建固定数目线程的线程池。任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</li><li>newScheduledThreadPool(int corePoolSize)：创建一个支持定时及周期性的任务执行的线程池。这个池子里的线程可以按 schedule 依次 延期执行，或周期执行。</li><li>SingleThreadExecutor()：单例线程，任意时间池中只能有一个线程。</li></ul><p><strong>Executor执行Runnable任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(()-&gt;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Executor 执行Callable任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    List&lt;Future&lt;String&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(()-&gt;</span><br><span class="line">          Thread.currentThread().getName());</span><br><span class="line">        resultList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;String&gt; fs : resultList)&#123;   </span><br><span class="line">                <span class="keyword">try</span>&#123;   </span><br><span class="line">                  <span class="comment">//Future返回如果没有完成，则一直循环等待，直到Future返回完成  </span></span><br><span class="line">                    <span class="keyword">while</span>(!fs.isDone());</span><br><span class="line">                    System.out.println(fs.get()); </span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException|ExecutionException e)&#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;   </span><br><span class="line">                    <span class="comment">//启动一次顺序关闭，执行以前提交的任务，但不接受新任务  </span></span><br><span class="line">                    executorService.shutdown();   </span><br><span class="line">                &#125;   </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义线程池</strong><br>可以用 ThreadPoolExecutor 类创建，它有4个构造方法来创建线程池，用该类很容易实现自定义的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        <span class="comment">//创建等待队列   </span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);   </span><br><span class="line">        <span class="comment">//创建线程池，池中保存的线程数为3，允许的最大线程数为5，</span></span><br><span class="line">        <span class="comment">//空闲线程有效期50毫秒 </span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">50</span>,TimeUnit.MILLISECONDS,bqueue);   </span><br><span class="line">        <span class="comment">//创建七个任务   </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">          pool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行。。。"</span>);   </span><br><span class="line">            <span class="keyword">try</span>&#123;   </span><br><span class="line">                Thread.sleep(<span class="number">100</span>);   </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">                e.printStackTrace();   </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//关闭线程池   </span></span><br><span class="line">        pool.shutdown();   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 excute方法将一个Runnable 任务添加到线程池中，按如下顺序执行</p><ol><li>如果线程池中的线程数量少于 corePoolSize（核心线程数），即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务。</li><li>如果线程池中的线程数量大于等于 corePoolSize，但workQueue（缓冲队列） 未满，则将新添加的任务放到 workQueue 中，按照 FIFO 的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）。</li><li>如果线程池中的线程数量大于等于 corePoolSize，且缓冲队列 workQueue 已满，但线程池中的线程数量小于 maximumPoolSize（最大线程数），则会创建新的线程来处理被添加的任务。</li><li>如果线程池中的线程数量等于了 maximumPoolSize，可以构造有RejectedExecutionHandler类型参数的构造方法，来处理溢出的任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure></li></ol><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-92131ffc6b771917.png" class="lozad"></p><ul><li>AbortPolicy：如果不能接受任务了，则抛出异常。</li><li>CallerRunsPolicy：如果不能接受任务了，则让调用的线程去完成。</li><li>DiscardOldestPolicy：如果不能接受任务了，则丢弃最老的一个任务，由一个队列来维护。</li><li>DiscardPolicy：如果不能接受任务了，则丢弃任务。</li></ul><p><strong>几种排队策略</strong></p><ul><li><em>直接切换</em> 缓冲队列采用 SynchronousQueue，它将任务直接交给线程处理而不保持它们。如果不存在可用于立即运行任务的线程（即线程池中的线程都在工作），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中。直接提交通常要求无界 maximumPoolSizes（Integer.MAX_VALUE） 以避免拒绝新提交的任务。newCachedThreadPool 采用的便是这种策略。</li><li><em>无界队列</em> 使用无界队列（典型的便是采用预定义容量的 LinkedBlockingQueue，理论上是该缓冲队列可以对无限多的任务排队）将导致在所有 corePoolSize 线程都工作的情况下将新任务加入到缓冲队列中。这样，创建的线程就不会超过 corePoolSize，也因此，maximumPoolSize 的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。newFixedThreadPool采用的便是这种策略。</li><li><em>有边界的队列。</em> 有限队列（例如， ArrayBlockingQueue）有助于在使用有限maxPoolSizes时防止资源耗尽，但可能更难调整和控制。 队列大小和最大池大小可能彼此交易：使用大队列和小型池可以最大限度地减少CPU使用率，OS资源和上下文切换开销，但可能导致人为的低吞吐量。 如果任务频繁阻塞（例如，如果它们是I / O绑定），则系统可能能够安排比你允许的更多线程的时间。 使用小型队列通常需要较大的池大小，这样可以使CPU繁忙，但可能会遇到不可接受的调度开销，这也降低了吞吐量。</li></ul><h4 id="2-倒计时器CountDownLatch"><a href="#2-倒计时器CountDownLatch" class="headerlink" title="2.倒计时器CountDownLatch"></a>2.倒计时器CountDownLatch</h4><p>CountDownLatch用来控制一个或者多个线程等待多个线程。它维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(total);</span><br><span class="line">        ExecutorService exe = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            exe.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-障碍器CyclicBarrier"><a href="#3-障碍器CyclicBarrier" class="headerlink" title="3.障碍器CyclicBarrier"></a>3.障碍器CyclicBarrier</h4><p>CylicBarrier和CountDownLatch相似，也是等待某些线程都做完以后再执行。与CountDownLatch区别在于这个计数器可以反复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">            <span class="comment">//创建CyclicBarrier对象，  </span></span><br><span class="line">            <span class="comment">//并设置执行完一组5个线程的并发任务后，再执行最后的任务  </span></span><br><span class="line">            CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, ()-&gt;</span><br><span class="line">                System.out.println(<span class="string">"执行最后的任务"</span>));   </span><br><span class="line">            <span class="keyword">new</span> SubTask(<span class="string">"A"</span>, cb).start();   </span><br><span class="line">            <span class="keyword">new</span> SubTask(<span class="string">"B"</span>, cb).start();   </span><br><span class="line">            <span class="keyword">new</span> SubTask(<span class="string">"C"</span>, cb).start();   </span><br><span class="line">            <span class="keyword">new</span> SubTask(<span class="string">"D"</span>, cb).start();   </span><br><span class="line">            <span class="keyword">new</span> SubTask(<span class="string">"E"</span>, cb).start();  </span><br><span class="line">    &#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTask</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> String name;   </span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cb;   </span><br><span class="line"></span><br><span class="line">    SubTask(String name, CyclicBarrier cb) &#123;   </span><br><span class="line">            <span class="keyword">this</span>.name = name;   </span><br><span class="line">            <span class="keyword">this</span>.cb = cb;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">            System.out.println(<span class="string">"["</span> + name + <span class="string">"] 开始执行"</span>);   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">888888</span>; i++) ;    <span class="comment">//耗时的任务   </span></span><br><span class="line">            System.out.println(<span class="string">"["</span> + name + <span class="string">"] 执行完毕，通知障碍器"</span>);   </span><br><span class="line">            <span class="keyword">try</span> &#123;   </span><br><span class="line">                    <span class="comment">//每执行完一项任务就通知障碍器   </span></span><br><span class="line">                    cb.await();   </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException|BrokenBarrierException  e) &#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">            &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-信号量Semaphore"><a href="#4-信号量Semaphore" class="headerlink" title="4.信号量Semaphore"></a>4.信号量Semaphore</h4><p>Semaphore 可以控制某个资源被同时访问的任务数，它通过acquire获取一个许可，release释放一个许可。如果被同时访问的任务数已满，则其他acquire的任务进入等待状态，直到有一个任务被release掉，它才能得到许可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();  </span><br><span class="line">    <span class="comment">//只允许5个线程同时访问  </span></span><br><span class="line">    <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n= <span class="number">0</span>; n&lt; <span class="number">10</span>; n++)&#123;  </span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> m = n;</span><br><span class="line">        exec.execute(()-&gt;&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;  </span><br><span class="line">                    <span class="comment">//获取许可  </span></span><br><span class="line">                    semp.acquire();  </span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> +   </span><br><span class="line">                        Thread.currentThread().getName() + <span class="string">"获得许可："</span>  + m);  </span><br><span class="line">                    <span class="comment">//耗时的任务  </span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">888888</span>; i++) ;  </span><br><span class="line">                    <span class="comment">//释放许可  </span></span><br><span class="line">                    semp.release();  </span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> +   </span><br><span class="line">                        Thread.currentThread().getName() + <span class="string">"释放许可："</span>  + m);  </span><br><span class="line">                    System.out.println(<span class="string">"当前允许进入的任务个数："</span> +  </span><br><span class="line">                        semp.availablePermits());  </span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    exec.shutdown();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="5-ForkJoin"><a href="#5-ForkJoin" class="headerlink" title="5.ForkJoin"></a>5.ForkJoin</h4><p>ForkJoin类似MapReduce算法，两者区别是：ForkJoin只有在必要时如任务非常大的情况下才分割成一个个小任务，而 MapReduce总是在开始执行第一步进行分割。可继承抽象类RecursiveAction（无返回值），RecursiveTask（有返回值）来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoin</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestForkJoin</span> <span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            TestForkJoin  leftTask = <span class="keyword">new</span> TestForkJoin(first, middle);</span><br><span class="line">            TestForkJoin  rightTask = <span class="keyword">new</span> TestForkJoin(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">      ExecutionException , InterruptedException  </span>&#123;</span><br><span class="line">       TestForkJoin  test = <span class="keyword">new</span> TestForkJoin (<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">       ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">       Future result = forkJoinPool.submit(test);</span><br><span class="line">       System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。<br>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p><h4 id="6-并发容器"><a href="#6-并发容器" class="headerlink" title="6.并发容器"></a>6.并发容器</h4><p>我们知道HashMap不是一个线程安全的容器，最简单的方式使HashMap变成线程安全就是使用Collections.synchronizedMap，它是对HashMap的一个包装。<br><code>public static Map m=Collections.synchronizedMap(new HashMap());</code><br>同理对于List，Set也提供了相似方法。但是这种方式只适合于并发量比较小的情况。<br>查看源码可以知道，synchronizedMap会将HashMap包装在里面，然后将HashMap的每个操作都加上synchronized。由于每个方法都是获取同一把锁，这就意味着，put和remove等操作是互斥的，大大减少了并发量。</p><p>通常我们会使用JUC包下的ConcurrentHashMap类。在 ConcurrentHashMap内部有一个Segment段，它将HashMap切分成若干个段（小的HashMap），然后让数据在每一段上Hash，这样多个线程在不同段上的Hash操作一定是线程安全的，所以只需要同步同一个段上的线程就可以了，这样实现了锁的分离，大大增加了并发量。<br>在使用ConcurrentHashMap.size()时会比较麻烦，因为它要统计每个段的数据和，在这个时候，要把每一个段都加上锁，然后再做数据统计。</p><h4 id="7-锁优化"><a href="#7-锁优化" class="headerlink" title="7.锁优化"></a>7.锁优化</h4><p>这里的锁优化，是指在阻塞式的情况下，如何让性能不要变得太差。<br>锁优化主要有一下几个方面：</p><ul><li>减少锁持有时间。比如在使用synchronized时，保证线程安全前提下，尽量使用同步块，减少直接在方法上使用。</li><li>减小锁粒度。将大的对象（这个对象会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。比如ConcurrentHashMap就是使用了这一点。</li><li>锁分离。比如读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。</li><li>锁粗化。通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。但是，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统资源，反而不利于性能的优化 。比如在一个方法中有很多的synchronized块，可以考虑把这些小块合并成大块。</li><li>锁消除。锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。比如Vector和StringBuffer这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性能。在server模式下开启锁消除<code>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</code>。</li></ul><p><strong>JVM虚拟机对synchronized 的优化</strong><br>自旋锁<br>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。<br>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>偏向锁和轻量级锁<br>锁拥有的四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。<br>轻量级锁相对于传统的重量级锁而言，它使用 CAS（比较并替换） 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。<br>以下图片是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-1ed41f7b77e390e7.png" class="lozad"><br>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><p>偏向锁即锁会偏向于当前已经占有锁的线程 。<br>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向后恢复到未锁定状态或者轻量级锁状态。</p><p><strong>参考资料</strong><br><a href="https://my.oschina.net/hosee/blog/597934" target="_blank" rel="noopener">高并发Java</a><br>JDK1.8-API</p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读懂Java多线程与并发-基础篇</title>
      <link href="/post/2019/3/4/"/>
      <url>/post/2019/3/4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="1-几个重要概念"><a href="#1-几个重要概念" class="headerlink" title="1.几个重要概念"></a>1.几个重要概念</h4><p><strong>同步与异步</strong><br>同步调用会等待方法的返回，异步调用会瞬间返回，但是异步调用瞬间返回并不代表你的任务就完成了，它会在后台起个线程继续进行任务。<br><strong>阻塞和非阻塞</strong><br>阻塞和非阻塞通常形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。非阻塞允许多个线程同时进入临界区。<br><strong>并发和并行</strong><br>并行则是两个任务同时进行，而并发呢，则是一会做一个任务一会又切换到另一个任务。所以单个cpu是不能做到并行的，只能是并发。<br><strong>临界区</strong><br>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。<br><strong>死锁</strong><br>是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法进行下去。比如线程1占了B资源，请求A资源，线程2占了A资源，请求B资源。<br><strong>活锁</strong><br>线程1可以使用资源，但它让其他线程先使用资源；线程2也可以使用资源，但它也让其他线程先使用资源，于是两者一直谦让，都无法使用资源。</p><h4 id="2-使用线程"><a href="#2-使用线程" class="headerlink" title="2.使用线程"></a>2.使用线程</h4><p><img alt="线程状态转换" data-src="https://upload-images.jianshu.io/upload_images/18796269-b29c2a760e32d177.png" class="lozad"></p><p>有三种方法可以创建线程</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HI"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestRunnable test1 = <span class="keyword">new</span> TestRunnable ();</span><br><span class="line">    Thread t1= <span class="keyword">new</span> Thread(test1);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    TestCallable test2 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">    FutureTask&lt;String&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(test2);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    t2.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line"></span><br><span class="line">    TestThread t3 = <span class="keyword">new</span> TestThread();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程中断</strong><br>当一个线程正在运行时，另一个线程调用对应的 Thread 对象的 interrupt()方法来中断它，只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。但实际上线程并没有被中断，还会继续往下执行。</p><p>线程中断的3个方法</p><ul><li>interrupt() 中断线程 </li><li>isInterrupted()  判断是否被中断</li><li>interrupted()  判断是否被中断，并清除当前中断状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span>  <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"in TestInterrupt() - start"</span>);  </span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);  </span><br><span class="line">            System.out.println(<span class="string">"in TestInterrupt() - woke up"</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            System.out.println(<span class="string">"in TestInterrupt() - interrupted"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">"in TestInterrupt() - leaving"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        TestInterrupt  test= <span class="keyword">new</span> TestInterrupt();  </span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(test);  </span><br><span class="line">        t.start();  </span><br><span class="line">        <span class="comment">//主线程休眠2秒，从而确保刚才启动的线程有机会执行一段时间  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);   </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">"in main() - interrupting other thread"</span>);  </span><br><span class="line">        <span class="comment">//中断线程t  </span></span><br><span class="line">        t.interrupt();  </span><br><span class="line">        System.out.println(<span class="string">"in main() - leaving"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会输出 in TestInterrupt () - leaving。</p><h4 id="3-线程间协作"><a href="#3-线程间协作" class="headerlink" title="3.线程间协作"></a>3.线程间协作</h4><p><strong>线程等待与唤醒</strong><br>调用 wait() 使得线程被挂起，当其他线程调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于Object，而不属于 Thread。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestWait test = <span class="keyword">new</span> TestWait ();</span><br><span class="line">     <span class="keyword">new</span> Thread(()-&gt;test.after()).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(()-&gt;test.before()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait() 和 sleep() 的区别</p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><p>java.util.concurrent 类库中提供了 Condition 类，可调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。用法跟上面的类似，只是把同步块synchronized换成了同步锁ReentrantLock。<br>两者的区别：</p><ul><li>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>synchronized 是非公平的，ReentrantLock 默认情况下也是非公平的，但是可以实现公平锁。</li><li>ReentrantLock 等待可中断，而 synchronized 不行。</li><li>ReentrantLock 可以同时绑定多个条件Condition。</li><li>ReentrantLock 可重入，一个线程可以反复得到相同的一把锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAwait</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>join()</strong><br>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">printNum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">num=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">TestJoin test = <span class="keyword">new</span> TestJoin ();</span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(()-&gt;test.printNum()).start();</span><br><span class="line">                 t.join();</span><br><span class="line">                 System.out.println(test.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-内存模型"><a href="#4-内存模型" class="headerlink" title="4.内存模型"></a>4.内存模型</h4><p><strong>主内存与工作内存</strong><br>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量主要是指共享变量。Java 内存模型规定所有的变量都存储在主内存中，而每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来完成。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-43d8a200dd78d6e2.png" class="lozad"><br>Java 内存模型中定义了以下 8 种操作来完成主内存与工作内存之间交互的实现细节。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-70abb9a7c4e68d62.png" class="lozad"></p><ul><li>luck（锁定）：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的 load 动作使用。</li><li>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后的 write 操作使用。</li><li>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量值放入主内存的变量中。</li></ul><p><strong>三大特性</strong></p><ul><li>原子性：指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。</li><li>有序性：在并发时，程序的执行可能就会出现乱序。因为指令有可能被重排。</li><li>内存可见性：指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。</li></ul><h4 id="5-volatile和ThreadLocal"><a href="#5-volatile和ThreadLocal" class="headerlink" title="5.volatile和ThreadLocal"></a>5.volatile和ThreadLocal</h4><p>volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>volatile 是一种稍弱的同步机制，在访问 volatile 变量时不会执行加锁操作，也就不会执行线程阻塞，因此 volatilei 变量是一种比 synchronized 关键字更轻量级的同步机制。<br>volatile 虽然保证了内存可见性和有序性（添加内存屏障的方式来禁止指令重排），但不能保证原子性，所以是线程不安全的。</p><p>ThreadLocal是解决线程安全问题一个很好的思路，ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本，由于Key值不可重复，每一个“线程对象”对应线程的“变量副本”，而到达了线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqNum = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    seqNum.set(seqNum.get()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> seqNum.get();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    TestThreadLocal test = <span class="keyword">new</span> TestThreadLocal();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread["</span>+Thread.currentThread().getName()+</span><br><span class="line">                  <span class="string">"] num["</span>+test.getNextNum()+<span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">      &#125;) .start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread["</span>+Thread.currentThread().getName()+</span><br><span class="line">                  <span class="string">"] num["</span>+test.getNextNum()+<span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">      &#125;) .start();</span><br><span class="line">     <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread["</span>+Thread.currentThread().getName()+</span><br><span class="line">                  <span class="string">"] num["</span>+test.getNextNum()+<span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">      &#125;) .start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal和线程同步机制比较</p><ul><li>同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的。</li><li>ThreadLocal会为每一个线程拷贝一份独立的变量副本，从而隔离了多个线程对数据的访问冲突。<br>当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。</li></ul><p><strong>参考资料</strong><br><a href="https://my.oschina.net/hosee/blog/597934" target="_blank" rel="noopener">高并发Java</a><br><a href="http://ifeve.com/thread-signaling/#missed_signal" target="_blank" rel="noopener">线程通信</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全面的常用SpringBoot注解宝典</title>
      <link href="/post/2019/4/1/"/>
      <url>/post/2019/4/1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="表格中列出了springboot-spring框架自带的常用注解"><a href="#表格中列出了springboot-spring框架自带的常用注解" class="headerlink" title="表格中列出了springboot,spring框架自带的常用注解"></a>表格中列出了springboot,spring框架自带的常用注解</h3><table><thead><tr><th>注解</th><th>使用位置</th><th>描述</th></tr></thead><tbody><tr><td>@Configuration</td><td>类</td><td>相当于传统的xml配置文件，通过@Configuration类作为项目的配置类，可称JavaConfig</td></tr><tr><td>@EnableAutoConfiguration</td><td>类</td><td>开启SpringBoot自动配置</td></tr><tr><td>@ComponentScan</td><td>类</td><td>自动扫描注册组件</td></tr><tr><td>@SpringBootApplication</td><td>类</td><td>@Configuration+@EnableAutoConfiguration+@ComponentScan</td></tr><tr><td>@Controller</td><td>类</td><td>描述控制层类,自动扫描后，被注册。</td></tr><tr><td>@Service</td><td>类</td><td>描述业务层类,自动扫描后，被注册。</td></tr><tr><td>@Repository</td><td>类</td><td>描述DAO层类,自动扫描后，被注册。</td></tr><tr><td>@Component</td><td>类</td><td>泛指组件，自动扫描后，被注册。</td></tr><tr><td>@ResponseBody</td><td>类，方法</td><td>方法返回结果写入到response body中，一般用于构建RESTful的api</td></tr><tr><td>@RestController</td><td>类</td><td>@Controller+@ResponseBody</td></tr><tr><td>@RequestMapping</td><td>类，方法</td><td>配置路由，负责URL到Controller中的具体方法的映射</td></tr><tr><td>@GetMapping</td><td>方法</td><td>相当于@RequestMapping(method=RequestMethod.GET)</td></tr><tr><td>@PostMapping</td><td>方法</td><td>相当于@RequestMapping(method=RequestMethod.POST)</td></tr><tr><td>@PathVariable</td><td>方法参数</td><td>获取URL路径中的动态参数值，主要用于RESTful</td></tr><tr><td>@Autowired</td><td>除类</td><td>按类型自动导入依赖</td></tr><tr><td>@Qualifier</td><td>除类</td><td>配合@Autowired一起使用，按名称自动导入依赖</td></tr><tr><td>@RequestBody</td><td>方法参数</td><td>用来获取请求中的json对象</td></tr><tr><td>@RequestParam</td><td>方法参数</td><td>用来获取URL中的请求参数</td></tr><tr><td>@Import</td><td>类</td><td>导入其他配置类</td></tr><tr><td>@ImportResource</td><td>类</td><td>导入加载xml配置文件</td></tr><tr><td>@Bean</td><td>方法，注解</td><td>相当于xml中的bean标签,方法名为id,方法参数为引入相关类的依赖</td></tr><tr><td>@Primary</td><td>方法，类</td><td>一个接口多个实现类，只有标注了@Primary的类，才被依赖注入</td></tr><tr><td>@Value</td><td>除类，构造方法</td><td>注入配置文件的属性值</td></tr><tr><td>@PropertySource</td><td>类</td><td>引入properties配置文件，把数据存储到Spring的 Environment中</td></tr><tr><td>@ConfigurationProperties</td><td>类，方法</td><td>把指定配置文件的前缀属性值，自动封装在类中</td></tr><tr><td>@Order</td><td>类，方法，属性</td><td>加载顺序，值越小越先加载</td></tr><tr><td>@Scope</td><td>类，方法</td><td>类的范围，默认单例</td></tr><tr><td>@EnableTransactionManagement</td><td>类</td><td>开启事务管理</td></tr><tr><td>@Transcational</td><td>类，方法</td><td>使用事务</td></tr><tr><td>@EnableCaching</td><td>类</td><td>开启缓存</td></tr><tr><td>@Cacheable</td><td>类，方法</td><td>缓存数据</td></tr><tr><td>@CacheEvict</td><td>类，方法</td><td>删除缓存</td></tr><tr><td>@CachePut</td><td>类，方法</td><td>更新缓存</td></tr><tr><td>@CacheConfig</td><td>类</td><td>统一配置缓存</td></tr><tr><td>@EnableScheduling</td><td>类</td><td>开启对计划任务的支持</td></tr><tr><td>@Scheduled</td><td>方法，注解</td><td>声明一个计划任务</td></tr><tr><td>@ControllerAdvice</td><td>类</td><td>包含@Component，增强类，一般与@ExceptionHandler、@InitBinde、@ModelAttribute搭配使用</td></tr><tr><td>@ExceptionHandler</td><td>方法</td><td>捕获异常类</td></tr><tr><td>@InitBinde</td><td>方法</td><td>主要用来自定义格式化请求参数</td></tr><tr><td>@ModelAttribute</td><td>方法</td><td>其注解的方法将在Controll方法之前执行</td></tr><tr><td>@DependsOn</td><td>类，方法</td><td>控制bean加载顺序，先加载@DependsOn中的bean</td></tr><tr><td>@ConditionalOnBean</td><td>类，方法</td><td>当容器里面有指定的 Bean 的条件下注册类，一般与@Bean,@Component一起使用，以下几个Conditional也一样</td></tr><tr><td>@ConditionalOnClass</td><td>类，方法</td><td>当类路径下有指定的类的条件下</td></tr><tr><td>@ConditionalOnExpression</td><td>类，方法</td><td>基于SpEL表达式作为判断条件</td></tr><tr><td>@ConditionalOnJava</td><td>类，方法</td><td>基于JVM版本</td></tr><tr><td>@ConditionalOnJndi</td><td>类，方法</td><td>在JNDI存在的条件下查找指定的位置</td></tr><tr><td>@ConditionalOnMissingBean</td><td>类，方法</td><td>当容器里没有指定的 Bean 的情况下</td></tr><tr><td>@ConditionalOnMissingClass</td><td>类，方法</td><td>当类路径下没有指定的类的条件下</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>类，方法</td><td>当前项目不是web项目的条件下</td></tr><tr><td>@ConditionalOnProperty</td><td>类，方法</td><td>指定的属性是否等于指定的值</td></tr><tr><td>@ConditionalOnResourcce</td><td>类，方法</td><td>类路径下是否有指定的值</td></tr><tr><td>@EnableAsync</td><td>类</td><td>开启异步任务的支持</td></tr><tr><td>@Asyns</td><td>类，方法</td><td>声明一个异步任务</td></tr><tr><td>@Profile</td><td>类，方法</td><td>为不同环境下使用不同的配置</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2教程（五）整合Shiro</title>
      <link href="/post/2019/4/7/"/>
      <url>/post/2019/4/7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-ba42ec548fbaff3a.jpg" class="lozad"></p><blockquote><p>源码地址：<a href="https://github.com/q200737056/Spring-Course/tree/master/springboot2Shiro" target="_blank" rel="noopener">https://github.com/q200737056/Spring-Course/tree/master/springboot2Shiro</a></p></blockquote><h4 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h4><p>Java8+Maven3.3.9+SpringBoot2.0.4+Mybatis3+Shiro+H2+Eclipse<br><strong>注意：使用了H2嵌入式内存模式的数据库</strong><br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-1660604de97ae32c.png" class="lozad"></p><h4 id="2-Shiro简介"><a href="#2-Shiro简介" class="headerlink" title="2.Shiro简介"></a>2.Shiro简介</h4><p>Apache Shiro 是一个强大易用的 Java 安全框架，提供了认证、授权、加密和会话管理等功能，对于任何一个应用程序，Shiro 都可以提供全面的安全管理服务。并且相对于其他安全框架，Shiro 要简单的多。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-95c11e990e0b94fe.png" class="lozad"><br><strong>架构</strong></p><ul><li>Subject：主体，即subject记录了当前操作的主体。可能是一个通过浏览器请求的用户，也可能是一个运行的程序。</li><li>SecurityManager：安全管理器，它是shiro的核心。管理着认证，授权，session管理，缓存等。</li><li>Authentication：认证器，对用户身份进行认证。</li><li>Authorization：授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。</li><li>SessionManager：会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session。</li><li>SessionDAO：会话dao，是对session会话操作的一套接口。</li><li>CacheManager：缓存管理，将用户权限数据存储在缓存，这样可以提高性能。</li><li>Cryptography：密码管理，shiro提供了一套加密/解密的组件，保护数据的安全性，比如用户密码。</li><li>Realm：域，相当于数据源，SecurityManager需要通过Realm获取用户权限数据。</li></ul><h4 id="3-SpringBoot整合Shiro"><a href="#3-SpringBoot整合Shiro" class="headerlink" title="3.SpringBoot整合Shiro"></a>3.SpringBoot整合Shiro</h4><p><strong>jar包依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--省略sringboot等其它依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JavaConfig配置Shiro</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shiro过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//配置登录的url，如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">"/index/loginIndex"</span>);</span><br><span class="line">        <span class="comment">//未授权界面;配置不会被拦截的链接</span></span><br><span class="line">       <span class="comment">//shiroFilterFactoryBean.setUnauthorizedUrl("/index/noperms");</span></span><br><span class="line">        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问</span></span><br><span class="line">        </span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/h2-console/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/index/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/index/noperms"</span>, <span class="string">"anon"</span>);</span><br><span class="line">       <span class="comment">//filterChainDefinitionMap.put("/index/toAdd", "perms[user:add]");</span></span><br><span class="line">        <span class="comment">//filterChainDefinitionMap.put("/index/**", "authc");</span></span><br><span class="line">        </span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/index/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line">        <span class="comment">//主要这行代码必须放在所有权限设置的最后，user拦截表示 用户存在或记住我 可以访问</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"user"</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置核心安全管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userRealm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">(UserRealm  userRealm,</span></span></span><br><span class="line"><span class="function"><span class="params">          MemoryConstrainedCacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">         DefaultWebSecurityManager defaultSecurityManager = <span class="keyword">new</span> </span><br><span class="line">                DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">//设置 领域</span></span><br><span class="line">        defaultSecurityManager.setRealm(userRealm);</span><br><span class="line">        <span class="comment">//设置 缓存</span></span><br><span class="line">        defaultSecurityManager.setCacheManager(cacheManager());</span><br><span class="line">        <span class="comment">//设置 记住我</span></span><br><span class="line">        defaultSecurityManager.setRememberMeManager(rememberMeManager());</span><br><span class="line">        <span class="comment">//设置 session管理器</span></span><br><span class="line">        defaultSecurityManager.setSessionManager(sessionManager());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> defaultSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义凭证匹配器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleCredentialsMatcher <span class="title">customCredentialsMatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomCredentialsMatcher();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义Realm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserRealm realm = <span class="keyword">new</span> UserRealm();</span><br><span class="line">    realm.setCredentialsMatcher(customCredentialsMatcher());</span><br><span class="line">        <span class="keyword">return</span> realm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用shiro自带的缓存，当然还可以使用第三方缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemoryConstrainedCacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> MemoryConstrainedCacheManager();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会话管理管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSessionManager sessionManager = <span class="keyword">new</span> </span><br><span class="line">           DefaultWebSessionManager();</span><br><span class="line">        <span class="comment">//全局会话超时时间（单位毫秒），默认30分钟</span></span><br><span class="line">        sessionManager.setGlobalSessionTimeout(<span class="number">1800000</span>); </span><br><span class="line">        sessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">        <span class="comment">//删除过期的session</span></span><br><span class="line">        sessionManager.setDeleteInvalidSessions(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//是否开启会话验证器，默认是开启的</span></span><br><span class="line">        sessionManager.setSessionValidationSchedulerEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//去掉URL地标后面的JSESSIONID</span></span><br><span class="line">        sessionManager.setSessionIdUrlRewritingEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//定时清理失效会话, 清理用户直接关闭浏览器造成的孤立会话</span></span><br><span class="line">        sessionManager.setSessionValidationInterval(<span class="number">1800000</span>);</span><br><span class="line">        <span class="comment">//sessionID是否保存到cookie中</span></span><br><span class="line">        sessionManager.setSessionIdCookieEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//sessionID Cookie</span></span><br><span class="line">        sessionManager.setSessionIdCookie(sessionIdCookie());</span><br><span class="line">        <span class="keyword">return</span> sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会话DAO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionDAO <span class="title">sessionDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MemorySessionDAO sessionDAO = <span class="keyword">new</span> MemorySessionDAO();</span><br><span class="line">        <span class="keyword">return</span> sessionDAO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记住我 管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieRememberMeManager <span class="title">rememberMeManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CookieRememberMeManager manager = <span class="keyword">new</span> CookieRememberMeManager();</span><br><span class="line">    <span class="comment">//cookie加密 密钥 ，默认AES算法</span></span><br><span class="line">    manager.setCipherKey(Base64.decode(<span class="string">"4AvVhmFLUs0KTA3Kprsdag=="</span>));</span><br><span class="line">    manager.setCookie(rememberMeCookie());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 自动登录  Cookie</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleCookie <span class="title">rememberMeCookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法的参数 是cookie的名称</span></span><br><span class="line">        SimpleCookie cookie = <span class="keyword">new</span> SimpleCookie(<span class="string">"rememberMe"</span>);</span><br><span class="line">        <span class="comment">// 记住我cookie生效时间1天 ,单位秒</span></span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">86400</span>);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 会话Cookie 保存sessionID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleCookie <span class="title">sessionIdCookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法的参数 是cookie的名称</span></span><br><span class="line">        SimpleCookie cookie = <span class="keyword">new</span> SimpleCookie(<span class="string">"sid"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//关闭浏览器后 ，此cookie清除</span></span><br><span class="line">        cookie.setMaxAge(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * *</span></span><br><span class="line"><span class="comment">     * 开启Shiro的注解</span></span><br><span class="line"><span class="comment">     * 需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 配置以下两个bean</span></span><br><span class="line"><span class="comment">     * DefaultAdvisorAutoProxyCreator(可选，可以不用配置)</span></span><br><span class="line"><span class="comment">     * AOP方法级权限检查，扫描上下文，寻找所有的Advistor(通知器），将这些</span></span><br><span class="line"><span class="comment">           Advisor应用到所有符合切入点的Bean中。</span></span><br><span class="line"><span class="comment">     * AuthorizationAttributeSourceAdvisor AOP方法级权限检查</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@DependsOn</span>(&#123;<span class="string">"lifecycleBeanPostProcessor"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">advisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> </span><br><span class="line">            DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> advisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor </span><br><span class="line">         authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = </span><br><span class="line">        <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shiro生命周期处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最主要的三个一定要配置。ShiroFilterFactoryBean：主要是配置一些URL与拦截器。默认主要的拦截器有anon（可匿名访问），authc（需要身份认证），roles[XX]（需要拥有某些角色），perms[xx]（需要拥有某些权限），logout（登出）,user（需要存在用户或记住我）等。<br>SecurityManager ：需要配置自定义Realm。<br>UserRealm ：自定义Realm。继承AuthorizingRealm，实现了认证及授权。</p><blockquote><p>注意：为了使用注解方式，更加简便设置角色权限访问。需要借助AuthorizationAttributeSourceAdvisor 类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IndexService indexService;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection arg0)</span> </span>&#123;</span><br><span class="line">String username = (String) SecurityUtils.getSubject().getPrincipal();</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        Set&lt;String&gt; stringSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//这边直接赋权限了，正式项目中，从数据库查询该用户的角色（role），</span></span><br><span class="line">        <span class="comment">//角色的权 限(perm)</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"admin"</span>.equals(username))&#123;</span><br><span class="line">        stringSet.add(<span class="string">"user:query"</span>);</span><br><span class="line">               stringSet.add(<span class="string">"user:update"</span>);</span><br><span class="line">               stringSet.add(<span class="string">"user:add"</span>);</span><br><span class="line">              stringSet.add(<span class="string">"user:delete"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        stringSet.add(<span class="string">"user:query"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info.setStringPermissions(stringSet);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 身份认证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String userName = (String) token.getPrincipal();</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        String userPwd = <span class="keyword">this</span>.indexService.login(userName);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (userPwd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();<span class="comment">//用户名不存在</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(userName, userPwd,getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例中自定义了凭证匹配器。当然可以直接使用Shiro自带的HashedCredentialsMatcher注入一些必要的参数<code>setHashAlgorithmName(&quot;md5&quot;) setHashIterations(2)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title">SimpleCredentialsMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token,</span></span></span><br><span class="line"><span class="function"><span class="params">                  AuthenticationInfo info)</span> </span>&#123;</span><br><span class="line">    UsernamePasswordToken utoken=(UsernamePasswordToken) token;</span><br><span class="line">        <span class="comment">//获得用户输入的密码</span></span><br><span class="line">        String inPassword = <span class="keyword">new</span> String(utoken.getPassword());</span><br><span class="line">        <span class="comment">//获得数据库中的密码</span></span><br><span class="line">        String dbPassword=(String) info.getCredentials();</span><br><span class="line">        <span class="comment">//进行密码的比对(可以采用加盐的方式去检验，这边直接明文匹配)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.equals(inPassword, dbPassword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller</strong><br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-2defba99ce76c069.png" class="lozad"><br>以下截取了一部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>()</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">String name = (String)subject.getPrincipal();</span><br><span class="line">System.out.println(<span class="string">"subject:"</span>+name);</span><br><span class="line">session.setAttribute(<span class="string">"username"</span>, name);</span><br><span class="line"><span class="comment">//System.out.println("==="+subject.getSession().getAttribute("username"));</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"forward:/index/userList"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/loginIndex"</span>,method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">loginIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  登陆</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@PostMapping</span>相当于<span class="doctag">@RequestMapping</span>(method=RequestMethod.POST)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String name,String password,String rememberMe</span></span></span><br><span class="line"><span class="function"><span class="params">,ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> booRememberMe = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"true"</span>.equals(rememberMe))&#123;</span><br><span class="line">    booRememberMe=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// System.out.println("===="+booRememberMe);</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">UsernamePasswordToken usernamePasswordToken=<span class="keyword">new</span> </span><br><span class="line">UsernamePasswordToken(name,password,booRememberMe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">subject.login(usernamePasswordToken);   <span class="comment">//登录</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">modelMap.put(<span class="string">"msg"</span>, <span class="string">"用户名不存在！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">modelMap.put(<span class="string">"msg"</span>, <span class="string">"密码不正确！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">           modelMap.put(<span class="string">"msg"</span>, <span class="string">"账户已锁定！"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ExcessiveAttemptsException eae) &#123;</span><br><span class="line">           modelMap.put(<span class="string">"msg"</span>, <span class="string">"密码错误次数过多！"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">           modelMap.put(<span class="string">"msg"</span>, <span class="string">"用户名或密码不正确！"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"forward:/index"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这边自定义logout</span></span><br><span class="line"><span class="comment"> * shiro有默认logout,会自动清除相关信息，返回配置的登陆页面</span></span><br><span class="line"><span class="comment"> * 用户登出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       subject.logout();</span><br><span class="line"></span><br><span class="line">       modelMap.put(<span class="string">"msg"</span>,<span class="string">"安全退出！"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列出 所有用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/userList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">userList</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; userList = <span class="keyword">this</span>.indexService.findUserList();</span><br><span class="line">modelMap.put(<span class="string">"userList"</span>, userList);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"userList"</span>;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequiresPermissions</span>：shiro权限配置</span></span><br><span class="line"><span class="comment"> * 如果没有权限的用户操作，会报错</span></span><br><span class="line"><span class="comment"> * 解决方法1.捕获异常，后续进行相关提示或操作。</span></span><br><span class="line"><span class="comment"> * 解决方法2.配置拦截  比如 /index/queryUser=perms[user:query];</span></span><br><span class="line"><span class="comment"> * ShiroFilterFactoryBean设置没权限时的url setUnauthorizedUrl("/index/noperms")</span></span><br><span class="line"><span class="comment"> * 这里使用了方法1  全局异常捕获处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:query"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/queryUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryUser</span><span class="params">(User user,ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">this</span>.indexService.queryUserBy(user);</span><br><span class="line">   </span><br><span class="line">    modelMap.put(<span class="string">"userList"</span>, userList);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"userList"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>登录页面</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/index/login"</span> <span class="attr">method</span>=<span class="string">"post"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 400px;margin:30px auto;"</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    自动登录<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"rememberMe"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg==null?'':msg&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例中实现了Shiro记住我，自动登录功能。注意的是需要配置Cookie来保存登录用户名及密码。为了安全考虑需要配置加密算法及密钥，Shiro默认AES算法。实例中还使用了Base64编码过的密钥，隐藏了明文。<br>还有一个需要注意的是当认证过的用户，没有权限操作时，方法会报没有权限异常UnauthorizedException，解决方法有二种。</p><ul><li>配置URL拦截，比如<code>/index/queryUser=perms[user:query]</code>，ShiroFilterFactoryBean设置没权限时跳转的URL<code>setUnauthorizedUrl(&quot;/index/noperms&quot;)</code>。</li><li>使用注解，捕获异常。</li></ul><p>推荐使用第二种方式，比较灵活，简便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;UnauthorizedException.class&#125;)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.OK)</span><br><span class="line">    <span class="keyword">public</span> ModelAndView handleUnauthenticatedException</span><br><span class="line">            (UnauthorizedException e) &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"exception"</span>, e);</span><br><span class="line">        mv.setViewName(<span class="string">"noPerms"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="欢迎关注我的公众号" data-src="https://upload-images.jianshu.io/upload_images/18796269-b4470caad6886568.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springBoot </tag>
            
            <tag> mybatis </tag>
            
            <tag> h2 </tag>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2教程（四）整合缓存Redis</title>
      <link href="/post/2019/4/6/"/>
      <url>/post/2019/4/6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-a671c422f025cbfc.jpg" class="lozad"></p><blockquote><p>源码地址：<a href="https://github.com/q200737056/Spring-Course/tree/master/springboot2Redis" target="_blank" rel="noopener">https://github.com/q200737056/Spring-Course/tree/master/springboot2Redis</a></p></blockquote><h4 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h4><p>Java8+Maven3.3.9+SpringBoot2.0.4+Mybatis3+Redis+H2+Eclipse<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-afdad93790f9977d.png" class="lozad"></p><h4 id="2-Redis简介"><a href="#2-Redis简介" class="headerlink" title="2.Redis简介"></a>2.Redis简介</h4><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p><strong>Redis具有以下优势</strong></p><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子性 – Redis的所有操作都是原子性的，要么成功执行要么失败不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期,master-slave模式的数据备份等特性。<br>下载windows版Redis地址：<br><a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a><br><img alt="开启Redis服务" data-src="https://upload-images.jianshu.io/upload_images/18796269-5019a61dd7eb9f11.png" class="lozad"></li></ul><h4 id="3-H2数据库简介"><a href="#3-H2数据库简介" class="headerlink" title="3.H2数据库简介"></a>3.H2数据库简介</h4><p>H2数据库一般适合作为嵌入式数据库使用，而其它的数据库大部分都需要安装独立的客户端和服务器端，如mysql等。</p><p><strong>H2的优势</strong></p><ul><li>H2采用纯Java编写，因此不受平台的限制。</li><li>H2只有一个jar文件，十分适合作为嵌入式数据库使用。</li><li>H2提供了一个十分方便的web控制台用于操作和管理数据库内容。</li></ul><p>H2数据库下载地址：<a href="http://www.h2database.com/html/download.html" target="_blank" rel="noopener">http://www.h2database.com/html/download.html</a><br>运行H2 bin目录下的 h2.bat 或h2w.bat 启动H2数据库。输入<a href="http://localhost:8082访问H2数据库的Web">http://localhost:8082访问H2数据库的Web</a> Console。如图：<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-6edf8d22bd72af44.png" class="lozad"><br><strong>本教程实例中已内嵌H2数据库，不需要单独启用。</strong></p><h4 id="4-SpringBoot整合Redis"><a href="#4-SpringBoot整合Redis" class="headerlink" title="4.SpringBoot整合Redis"></a>4.SpringBoot整合Redis</h4><p><strong>jar包依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--省略sringboot等其它依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- h2嵌入式数据库 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用redis连接池 必须有pool依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">    lettuce:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="number">10000</span><span class="string">ms</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>springboot2.x默认使用lettuce，如果想要使用jedis，可引入其jar包，修改配置为jedis。Redis默认密码为空，所以不用配置。如果想设置密码，打开Redis根目录下的xx.conf的文件,比如使用了redis.conf配置文件。找到requirepass添加自己想要设置的密码。之后重启Redis服务使之生效。</p><p><strong>JavaConfig配置Redis</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; redisTemplate</span><br><span class="line">(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        Jackson2JsonRedisSerializer serializer = <span class="keyword">new</span> </span><br><span class="line">     Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"> </span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"> </span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 生成一个默认配置，通过config对象即可对缓存进行自定义配置</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">//  设置缓存的默认过期时间3分，使用Duration设置</span></span><br><span class="line">        config = config.entryTtl(Duration.ofMinutes(<span class="number">3</span>))  </span><br><span class="line">        <span class="comment">// 不缓存空值  </span></span><br><span class="line">                .disableCachingNullValues();     </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 设置一个初始化的缓存空间set集合</span></span><br><span class="line">        Set&lt;String&gt; cacheNames =  <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cacheNames.add(<span class="string">"default"</span>);</span><br><span class="line">        cacheNames.add(<span class="string">"user"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 对每个缓存空间应用不同的配置</span></span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; configMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        configMap.put(<span class="string">"default"</span>, config);</span><br><span class="line">        configMap.put(<span class="string">"user"</span>, config.entryTtl(Duration.ofSeconds(<span class="number">120</span>)));</span><br><span class="line">       <span class="comment">// 使用自定义的缓存配置初始化一个cacheManager</span></span><br><span class="line">        RedisCacheManager cacheManager = </span><br><span class="line">RedisCacheManager.builder(redisConnectionFactory)</span><br><span class="line">        <span class="comment">// 注意这两句的调用顺序，一定要先调用该方法设置初始化的缓存名，再初始化相关的配置</span></span><br><span class="line">                .initialCacheNames(cacheNames)  </span><br><span class="line">                .withInitialCacheConfigurations(configMap)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>启动H2数据库内存模式并初始化表数据</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="comment">#使用TCP/IP的服务器模式</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:h2:tcp://localhost/mem:demo</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2dbStart</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span>  </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"正在启动h2数据库..."</span>);</span><br><span class="line">            Server.createTcpServer().start(); </span><br><span class="line">            System.out.println(<span class="string">"h2数据库启动成功..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"启动h2数据库出错："</span> + e.toString());  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2DataInit</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DruidDataSource druidDataSource;</span><br><span class="line"><span class="comment">//初始化h2 数据库表和数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"> String sql1 = <span class="string">"CREATE TABLE TEST_USER(id INT NOT NULL AUTO_INCREMENT, "</span></span><br><span class="line"> + <span class="string">"name VARCHAR(30),password VARCHAR(30), email VARCHAR(100),"</span></span><br><span class="line"> + <span class="string">"PRIMARY KEY (id))"</span>;</span><br><span class="line"> String sql2=<span class="string">"INSERT INTO test_user (id, name, password, email) "</span></span><br><span class="line"> + <span class="string">"VALUES (1, 'admin', 'admin', '1111@qq.com')"</span>;</span><br><span class="line"> String sql3=<span class="string">"INSERT INTO test_user (id, name, password, email) "</span></span><br><span class="line"> + <span class="string">"VALUES (2, 'hehe', 'hehe', '119@qq.com')"</span>;</span><br><span class="line"> Connection connection = <span class="keyword">null</span>;</span><br><span class="line"> Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">connection = druidDataSource.getConnection();</span><br><span class="line">stmt = connection.createStatement();</span><br><span class="line">stmt.addBatch(sql1);</span><br><span class="line">stmt.addBatch(sql2);</span><br><span class="line">stmt.addBatch(sql3);</span><br><span class="line">stmt.executeBatch();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                 stmt.close();</span><br><span class="line">                 connection.close();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                 e2.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">System.out.println(<span class="string">"初始化表数据完成。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存模式的数据库，只在服务运行时存在，一旦停止服务，数据库也随之而去。配置servlet<code>new ServletRegistrationBean&lt;&gt;(new WebServlet(),&quot;/h2/*&quot;)</code>，启动服务后，可通过<a href="http://localhost:8080/h2/访问h2数据库。">http://localhost:8080/h2/访问h2数据库。</a></p><p><strong>启动类@EnableCaching开启缓存</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.springboot2.test4.dao"</span>)</span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">        System.out.println(<span class="string">"启动成功。。。。。。。。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务层@Cacheable,@CachePut,@CacheEvict</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"user"</span>,key=<span class="string">"'user'+#id"</span>,unless = <span class="string">"#result eq null"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"去查询数据库。。。"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.indexDao.queryUserById(Integer.valueOf(id));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CachePut</span>(value=<span class="string">"user"</span>,key=<span class="string">"'user'+#user.id"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.indexDao.updateUser(user);</span><br><span class="line"> <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CacheEvict</span>(value=<span class="string">"user"</span>,key=<span class="string">"'user'+#id"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.indexDao.deleteUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存注解的说明可参考本人的上一篇文章<a href="https://www.jianshu.com/p/16019daa0376" target="_blank" rel="noopener">SpringBoot2教程（三）整合缓存Ehcache</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springBoot </tag>
            
            <tag> mybatis </tag>
            
            <tag> redis </tag>
            
            <tag> h2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2教程（三）整合缓存Ehcache</title>
      <link href="/post/2019/4/5/"/>
      <url>/post/2019/4/5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-52988e58cdce8c89.jpg" class="lozad"></p><blockquote><p>源码地址：<a href="https://github.com/q200737056/Spring-Course/tree/master/springboot2Ehcache" target="_blank" rel="noopener">https://github.com/q200737056/Spring-Course/tree/master/springboot2Ehcache</a></p></blockquote><h4 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h4><p>Java8+Maven3.3.9+SpringBoot2.0.4+Mybatis3+Ehcache+Mysql+Eclipse<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-5e2b5b6eb4dab203.png" class="lozad"></p><h4 id="2-加入依赖及ehcache-xml"><a href="#2-加入依赖及ehcache-xml" class="headerlink" title="2.加入依赖及ehcache.xml"></a>2.加入依赖及ehcache.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--省略springboot等其它依赖--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ehcache缓存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在项目根目录下取名ehcache.xml，springboot会默认加载该配置；如若不然，可在application.yml或application.properties中配置路径。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">ehcache</span></span><br><span class="line"><span class="attr">    ehcache:</span></span><br><span class="line"><span class="attr">      config:</span> <span class="attr">classpath:/myehcache.xml</span></span><br></pre></td></tr></table></figure><p><strong>ehcache.xml标签及属性</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"myCache"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>diskStore标签：磁盘缓存位置</li><li>defaultCache标签：默认缓存</li><li>cache标签 ：自定义缓存</li><li>maxEntriesLocalHeap(旧版 maxElementsInMemory)：设置了缓存的上限,最多存储多少个对象</li><li>eternal：对象是否永不过期 (指定true则下面两项配置无效)</li><li>timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）</li><li>timeToLiveSeconds：设置对象允许存活时间（单位：秒）</li><li>overflowToDisk：内存中Element数量达到最大时是否允许对象被写入到磁盘</li><li>memoryStoreEvictionPolicy：当达到最大限制时，Ehcache将会根据指定的策略去清理内存;  默认策略是LRU（最近最少使用）FIFO（先进先出） LFU（最少使用）</li><li>maxEntriesLocalDisk：磁盘缓存最大对象数，默认为0不限制</li><li>diskExpiryThreadIntervalSeconds：磁盘缓存的清理线程运行间隔,默认是120秒</li><li>diskPersistent：是否持久化磁盘缓存，默认false</li><li>copyOnRead：当缓存项被读出时是否返回它的拷贝，默认false</li><li>copyOnWrite：当缓存项被写入时，是否写入到它的拷贝中，默认false</li></ul><h4 id="3-在启动类注解-EnableCaching开启缓存"><a href="#3-在启动类注解-EnableCaching开启缓存" class="headerlink" title="3.在启动类注解@EnableCaching开启缓存"></a>3.在启动类注解@EnableCaching开启缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.springboot2.test3.dao"</span>)</span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">        System.out.println(<span class="string">"启动成功。。。。。。。。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-业务层方法上加缓存"><a href="#4-业务层方法上加缓存" class="headerlink" title="4.业务层方法上加缓存"></a>4.业务层方法上加缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"myCache"</span>,key=<span class="string">"'user'+#id"</span>,unless = <span class="string">"#result eq null"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"去查询数据库。。。"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.indexDao.queryUserById(Integer.valueOf(id));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CachePut</span>(value=<span class="string">"myCache"</span>,key=<span class="string">"'user'+#user.id"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.indexDao.updateUser(user);</span><br><span class="line"> <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CacheEvict</span>(value=<span class="string">"myCache"</span>,key=<span class="string">"'user'+#id"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.indexDao.deleteUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要的几个缓存注解</strong></p><ul><li>@Cacheable：对方法配置，能够根据方法的请求参数对其进行缓存</li><li>@CacheEvict：清除缓存</li><li>@CachePut：主要用来更新缓存</li><li>@CacheConfig：统一配置类的缓存注解的属性</li></ul><p><strong>@Cacheable/@CachePut/@CacheEvict主要的参数</strong></p><ul><li>value：缓存的名称，在配置文件中定义</li><li>key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，<br>如果不指定，则缺省按照方法的所有参数进行组合</li><li>condition：缓存的条件，只有为 true才进行缓存/清除缓存</li><li>unless：与condition相反，只有为 false才进行缓存/清除缓存</li><li>allEntries：是否清空所有缓存内容，缺省为 false</li><li>beforeInvocation：是否在方法执行前就清空，缺省为 false；缺省情况下，如果方法 执行抛出异常，则不会清空缓存</li></ul><h4 id="5-简单介绍一下SpEL表达式"><a href="#5-简单介绍一下SpEL表达式" class="headerlink" title="5.简单介绍一下SpEL表达式"></a>5.简单介绍一下SpEL表达式</h4><p>其实在Spring3中就已经支持EL表达式了，简称SpEL。以前在xml配置中，经常会看到如下表达式<code>#{...}</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.***.Hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"item"</span> <span class="attr">value</span>=<span class="string">"#&#123;otherBean&#125;"</span> /&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 把otherBean注入到hello的item属性中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;otherBean.name&#125;"</span> /&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 把otherBean的name注入到hello的name属性中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpEL支持字符串，数字，布尔及null。当然也可以访问变量，对象的属性，对象的方法，集合，map，静态方法等。<code>#{person.name},#{person.getName()},#{list[0]},#{map[&#39;name&#39;]},#{T(Math).abs(-1)}</code><br>变量可以通过<code>StandardEvaluationContext</code>的<code>setVariable</code>方法设置到上下文中。当访问一个对象的属性或方法时, 若该对象为null, 就会出现空指针异常，可在对象后加<code>?</code>。</p><p><strong>Spring EL支持的操作符</strong></p><ul><li>关系操作符, 包括: <code>eq(==), ne(!=), lt()&lt;, le(&lt;=), gt(&gt;), ge(&gt;=)</code></li><li>逻辑运算符, 包括: <code>and(&amp;&amp;), or(||), not(!)</code></li><li>数学操作符, 包括: <code>加(+), 减(-), 乘(*), 除(/), 取模(%), 幂指数(^)</code></li><li>其他操作符, 如: <code>三元操作符, instanceof, 赋值(=), 正则匹配</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springBoot </tag>
            
            <tag> mybatis </tag>
            
            <tag> ehcache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2教程（二）整合Mybatis,dataSource,Thymeleaf</title>
      <link href="/post/2019/4/4/"/>
      <url>/post/2019/4/4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-32f119ec07178fb7.jpg" class="lozad"><br>本篇主要内容讲springboot怎么整合Mybatis，Druid，Thymeleaf，Logback及基本运用。</p><blockquote><p>源码地址：<a href="https://github.com/q200737056/Spring-Course/tree/master/springboot2Test2" target="_blank" rel="noopener">https://github.com/q200737056/Spring-Course/tree/master/springboot2Test2</a></p></blockquote><h4 id="一、项目环境"><a href="#一、项目环境" class="headerlink" title="一、项目环境"></a>一、项目环境</h4><p>Java8+Maven3.3.9+SpringBoot2.0.4+Mybatis3+Druid+Thymeleaf3+Logback+Mysql+Eclipse<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-d9447527631ec0e3.png" class="lozad"></p><h4 id="二、代码及配置讲解"><a href="#二、代码及配置讲解" class="headerlink" title="二、代码及配置讲解"></a>二、代码及配置讲解</h4><h5 id="1-引入依赖包"><a href="#1-引入依赖包" class="headerlink" title="1.引入依赖包"></a>1.引入依赖包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot 核心包 ,包含了自动配置、日志logback和YAML--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringBoot 支持aop切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SpringBoot Web开发，包含了jackson,Tomcat和spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打成jar时需要注释掉下面的配置,springboot内置集成tomcat--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;exclusions&gt;</span></span><br><span class="line"><span class="comment">                &lt;exclusion&gt;</span></span><br><span class="line"><span class="comment">                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">                &lt;/exclusion&gt;</span></span><br><span class="line"><span class="comment">            &lt;/exclusions&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringBoot集成thymeleaf模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SpringBoot集成mybatis框架 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringBoot集成阿里数据库连接池 druid--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mysql驱动包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot 热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 表示依赖不会传递 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-application-yml配置"><a href="#2-application-yml配置" class="headerlink" title="2.application.yml配置"></a>2.application.yml配置</h5><p>整合了Mybatis，Druid，Thymeleaf的配置，可以说非常方便，以下截取了配置部分。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Spring配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#thymeleaf配置，默认前缀为templates</span></span><br><span class="line"><span class="attr">  thymeleaf:</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">HTML</span></span><br><span class="line"><span class="attr">    encoding:</span> <span class="string">utf-8</span></span><br><span class="line">    <span class="comment"># 禁用缓存</span></span><br><span class="line"><span class="attr">    cache:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line">    <span class="comment">#springboot2.02版本默认使用HikariCP</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">    driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/demo?useUnicode=true</span></span><br><span class="line">          <span class="string">&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  devtools:</span></span><br><span class="line"><span class="attr">    restart:</span></span><br><span class="line">      <span class="comment">#热部署开关</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># MyBatis配置</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">    <span class="comment"># 搜索指定包别名</span></span><br><span class="line"><span class="attr">  typeAliasesPackage:</span> <span class="string">com.springboot2.test2</span></span><br><span class="line">    <span class="comment"># 配置mapper的扫描，找到所有的mapper.xml映射文件</span></span><br><span class="line"><span class="attr">  mapperLocations:</span> <span class="attr">classpath:mapper/*Mapper.xml</span></span><br><span class="line">    <span class="comment"># 加载全局的配置文件</span></span><br><span class="line"><span class="attr">  configLocation:</span> <span class="attr">classpath:property/mybatis-config.xml</span></span><br></pre></td></tr></table></figure><h5 id="3-logback日志配置"><a href="#3-logback日志配置" class="headerlink" title="3.logback日志配置"></a>3.logback日志配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--参数 日志路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.path"</span> <span class="attr">value</span>=<span class="string">"e:\logs"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--参数 日志格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; </span></span></span><br><span class="line"><span class="tag"><span class="string">[%thread] %-5level %logger&#123;20&#125; - [%method,%line] - %msg%n"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 临界值过滤器,过滤掉低于指定临界值的日志--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 日志级别排序为： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 在日志配置级别的基础上过滤掉info级别以下的日志 --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出到文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file_info"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/springboot2Test2-info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling</span></span></span><br><span class="line"><span class="tag"><span class="string">                      .TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按天回滚 daily --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/springboot2Test2-info.%d</span><br><span class="line">&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志最大的历史 60天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--级别过滤器，对特定某个级别的日志进行过滤--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 过滤的级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 匹配时的操作：接收（记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 不匹配时的操作：拒绝（不记录） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">additivity属性默认为true，向上级（即root）传递</span></span><br><span class="line"><span class="comment">                如果未设置level,默认继承root的level;</span></span><br><span class="line"><span class="comment">应没有设置appender-ref,此logger不输出日志</span></span><br><span class="line"><span class="comment">主要用来对各个包下的日志分类输出</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.springboot2.test2"</span> <span class="attr">level</span>=<span class="string">"info"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置日志级别,统一输出到appender-ref</span></span><br><span class="line"><span class="comment">注意如果存在log4j日志冲突，日志级别会变成debug,</span></span><br><span class="line"><span class="comment">                即使root设置了其它级别都不会生效</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"file_info"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>放在根目录下，配置文件名取logback.xml或logback-spring.xml，spring会默认加载。当然也可以取别的名称，在application.yml中配置，但不推荐这么做。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">logging</span></span><br><span class="line"><span class="attr">  config:</span> <span class="attr">classpath:mylogback.xml</span></span><br></pre></td></tr></table></figure><p><strong>logback常见的appender</strong></p><ul><li>ch.qos.logback.core.ConsoleAppender : 输出到控制台</li><li>ch.qos.logback.core.FileAppender：输出到文件</li><li>ch.qos.logback.core.rolling.RollingFileAppender：输出到文件，可以配置滚动策略</li></ul><p><strong>常见的日志格式符号</strong></p><ul><li>%logger{n}：输出Logger对象类名，n代表长度</li><li>%class{n}:输出所在类名</li><li>%d{pattern}或者%date{pattern}：输出日志日期，格式同java</li><li>%L或%line：日志所在行号</li><li>%m或%msg：日志内容</li><li>%method：所在方法名称</li><li>%-5level： 级别从左显示5个字符宽度</li><li>%thread：所在线程名称</li><li>%n : 换行</li></ul><h5 id="4-Thymeleaf"><a href="#4-Thymeleaf" class="headerlink" title="4.Thymeleaf"></a>4.Thymeleaf</h5><p>Thymeleaf是一种用于Web和独立环境服务器端的Java模板引擎，而且非常容易扩展。<br><strong>标准表达式语法</strong></p><ul><li><code>${...} :</code> 变量表达式。与spring集成后，使用spring EL。</li><li><code>*{...} :</code> 选择表达式。</li><li><code>#{...} :</code>消息 (i18n) 表达式。</li><li><code>@{...} :</code> 链接 (URL) 表达式。</li><li><code>~{...} :</code> 片段表达式。</li></ul><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//上下文相关URL</span><br><span class="line">&lt;a th:href=&quot;@&#123;/order/list&#125;&quot;&gt;</span><br><span class="line">//迭代列表</span><br><span class="line">&lt;tr th:each=&quot;user: $&#123;productList&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;userStat.count&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">         &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">         &lt;td th:text=&quot;$&#123;#numbers.formatDecimal(user.weight, 1, 2)&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">         &lt;td th:text=&quot;$&#123;#dates.format(user.logindate, &apos;dd-MM-yyyy&apos;)&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">   &lt;/tr&gt;</span><br></pre></td></tr></table></figure><h5 id="5-controller-mapperXML配置"><a href="#5-controller-mapperXML配置" class="headerlink" title="5.controller,mapperXML配置"></a>5.controller,mapperXML配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"><span class="comment">//日志示例， springboot默认采用logback日志，</span></span><br><span class="line">       <span class="comment">//一般最好都用slf4j日志门面创建，可以兼容多个日志，</span></span><br><span class="line"><span class="comment">//即使把 logback 换成 log4j2，日志代码都不会受到影响</span></span><br><span class="line"><span class="comment">//logback 详细配置可 查看 根目录下logback.xml</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(IndexController.class);</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IndexService indexService;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首页登陆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  登陆</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@PostMapping</span>相当于<span class="doctag">@RequestMapping</span>(method=RequestMethod.POST)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user,ModelMap modelMap,HttpSession session)</span></span>&#123;</span><br><span class="line">String pass = <span class="keyword">this</span>.indexService.login(user.getName());</span><br><span class="line"><span class="keyword">if</span>(pass==<span class="keyword">null</span>)&#123;</span><br><span class="line">modelMap.put(<span class="string">"msg"</span>, <span class="string">"用户名不存在！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!user.getPassword().equals(pass))&#123;</span><br><span class="line">modelMap.put(<span class="string">"msg"</span>, <span class="string">"密码错误！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"&#123;&#125;_用户登陆"</span>,user.getName());</span><br><span class="line">session.setAttribute(<span class="string">"username"</span>, user.getName());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"forward:/index/userList"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列出 所有用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/userList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">userList</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; userList = <span class="keyword">this</span>.indexService.findUserList();</span><br><span class="line">modelMap.put(<span class="string">"userList"</span>, userList);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"userList"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/toAdd"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"adduser"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/addUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.indexService.insertUser(user);</span><br><span class="line"><span class="comment">// redirect 重定向</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/index/userList"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/deleteUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.indexService.deleteUser(id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/index/userList"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.springboot2.test2.mapper.IndexDao"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 启动 mybatis 二级缓存,参数这里就不配置演示了，一般项目都会使用第三方缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"login"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">SELECT PASSWORD FROM TEST_USER WHERE NAME=#&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一般select  useCache默认true,flushCache默认false </span></span><br><span class="line"><span class="comment">insert,delete,update flushCache默认true </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span>  <span class="attr">resultType</span>=<span class="string">"User"</span> <span class="attr">useCache</span>=<span class="string">"true"</span> <span class="attr">flushCache</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">SELECT * FROM TEST_USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">INSERT INTO TEST_USER (NAME,PASSWORD,EMAIL) values</span><br><span class="line">(#&#123;name&#125;,#&#123;password&#125;,#&#123;email&#125;)</span><br><span class="line">]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">DELETE FROM TEST_USER WHERE ID=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="6-部分页面"><a href="#6-部分页面" class="headerlink" title="6.部分页面"></a>6.部分页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>  <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"springboot2实例教程"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"springboot2实例教程"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录成功<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;session.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>，登陆成功！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 600px;margin: 10px auto;"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"width: 100%"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">caption</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>电子邮箱<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Thymeleaf迭代 语法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;userList&#125;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.email&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index/deleteUser(id=$&#123;user.id&#125;)&#125;"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index/toAdd&#125;"</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springBoot </tag>
            
            <tag> mybatis </tag>
            
            <tag> thymeleaf </tag>
            
            <tag> druid </tag>
            
            <tag> logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2教程（一）快速创建web项目</title>
      <link href="/post/2019/4/3/"/>
      <url>/post/2019/4/3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-1dca379c8c6f105a.jpg" class="lozad"></p><p>现在很多项目中都使用了springboot，可见springboot是java开发人员不得不必会的框架技术。那么springboot有什么好处呢？</p><p>springboot是伴随着spring而生的，继承了spring的优秀基因。它的作用就是在于帮助开发者快速的搭建Spring框架，节省了很多配置，简化了编码。本着约定优于配置，可快速开发并运行起项目。本文我们将学习如何快速的创建一个springboot应用。</p><blockquote><p>源码地址：<a href="https://github.com/q200737056/Spring-Course/tree/master/springboot2Test1" target="_blank" rel="noopener">https://github.com/q200737056/Spring-Course/tree/master/springboot2Test1</a></p></blockquote><h4 id="一、项目环境"><a href="#一、项目环境" class="headerlink" title="一、项目环境"></a>一、项目环境</h4><p>Java8+Maven3.3.9+SpringBoot2.0.4+Eclipse<br><img alt="整个项目结构" data-src="https://upload-images.jianshu.io/upload_images/18796269-403a00bb8ecbcec1.png" class="lozad"></p><h4 id="二、代码及配置讲解"><a href="#二、代码及配置讲解" class="headerlink" title="二、代码及配置讲解"></a>二、代码及配置讲解</h4><p>怎么创建Maven项目，这里就不说。如果有人还不会，可以查看本人的另一篇文章。<br><a href="https://www.jianshu.com/p/5c59993faeec" target="_blank" rel="noopener">Maven如何构建项目</a></p><h5 id="1-首先看一下pom-xml"><a href="#1-首先看一下pom-xml" class="headerlink" title="1.首先看一下pom.xml"></a>1.首先看一下pom.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string"> http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.springboot2.test1<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot2Test1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot2Test1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>springboot2实例教程<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot 核心包 ,包含了自动配置、日志logback和YAML--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringBoot 支持aop切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringBoot Web开发，包含了jackson,Tomcat和spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打成jar时需要注释掉下面的配置,springboot内置集成tomcat--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;exclusions&gt;</span></span><br><span class="line"><span class="comment">                &lt;exclusion&gt;</span></span><br><span class="line"><span class="comment">                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">                &lt;/exclusion&gt;</span></span><br><span class="line"><span class="comment">            &lt;/exclusions&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringBoot集成 freemarker模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot 热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 表示依赖不会传递 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 构建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--生成jar,war的项目名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果没有该配置，devtools不会生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-application-yml"><a href="#2-application-yml" class="headerlink" title="2.application.yml"></a>2.application.yml</h5><p>springboot会默认加载项目根目录下的application.yml或application.properties。其实这两种文件差不多，用哪一种都可以，只是文件格式不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#服务配置</span><br><span class="line">server:</span><br><span class="line">  #服务端口</span><br><span class="line">  port: 8080</span><br><span class="line">  servlet:</span><br><span class="line">    # 项目contextPath</span><br><span class="line">    context-path: /</span><br><span class="line">  tomcat:</span><br><span class="line">    # tomcat的URI编码</span><br><span class="line">    uri-encoding: UTF-8</span><br><span class="line">    # tomcat最大线程数，默认为200</span><br><span class="line">    max-threads: 20</span><br><span class="line">    # Tomcat启动初始化的线程数，默认值25</span><br><span class="line">    min-spare-threads: 5</span><br></pre></td></tr></table></figure><p>上面我只列出了一部分YAML格式的配置，如果换成.properties文件，配置端口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></table></figure><p>YAML格式需要注意的是（1）子属性要缩进，而且缩进要相同，比如缩进2个空格，所有需要缩进的都要2个空格。（2）:后面需要加个空格。</p><h5 id="3-编码式配置文件"><a href="#3-编码式配置文件" class="headerlink" title="3.编码式配置文件"></a>3.编码式配置文件</h5><p>主要靠@Configuration注解来实现，比如像我这里项目的WebConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * addResourceHandlers方法处理静态资源  如图片，js，css,页面等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当你请求http://127.0.0.1:8080/page/index.html时，</span></span><br><span class="line">       <span class="comment">//会把resources/static/page/index.html返回。</span></span><br><span class="line"><span class="comment">//这里的静态资源是放置在WEB-INF目录下的</span></span><br><span class="line"><span class="comment">//一般情况下，WEB-INF目录下的资源是禁止直接访问的</span></span><br><span class="line"><span class="comment">//其实springboot默认 已经设置了 处理静态资源路径</span></span><br><span class="line"><span class="comment">// 默认 /**  配置classpath:/static,classpath:/public,classpath:/resources,</span></span><br><span class="line"><span class="comment">//classpath:/META-INF/resources,servlet context:/</span></span><br><span class="line">registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/static/"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * addViewControllers方法 可以很方便的实现一个请求到视图的映射</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//访问http://127.0.0.1:8080/时，会直接返回index.html页面</span></span><br><span class="line">registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"forward:"</span>+<span class="string">"/page/index.html"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * addInterceptors方法 设置拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 拦截 http://127.0.0.1:8080/index/ 的所有请求</span></span><br><span class="line"><span class="comment">//拦截器 按添加的顺序从前向后 依次执行preHandle，而postHandle，afterCompletion相反，从后向前</span></span><br><span class="line"><span class="comment">//addPathPatterns设置拦截路径  excludePathPatterns设置不拦截路径</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> LogHandlerInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>)</span><br><span class="line">.excludePathPatterns(<span class="string">"/index/system/**"</span>);</span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> Log2HandlerInterceptor()).addPathPatterns(<span class="string">"/index/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置过滤器 Filter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Bean</span>注解相当于 xml中的&lt;bean&gt;,方法名customFilter 即bean的id </span></span><br><span class="line"><span class="comment"> * 方法的参数名  即根据type依赖注入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">customFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line"> <span class="comment">//拦截的请求类型</span></span><br><span class="line"> registration.setDispatcherTypes(DispatcherType.REQUEST);</span><br><span class="line"> <span class="comment">//加入过滤器</span></span><br><span class="line"> registration.setFilter(<span class="keyword">new</span> CustomFilter());</span><br><span class="line"> <span class="comment">//拦截路径</span></span><br><span class="line"> registration.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line"> <span class="comment">//设置过滤器名称</span></span><br><span class="line"> registration.setName(<span class="string">"customFilter"</span>);</span><br><span class="line"> <span class="comment">//设置过滤器执行顺序  值越大，执行顺序越靠后</span></span><br><span class="line"> registration.setOrder(Integer.MAX_VALUE);</span><br><span class="line"> <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点说一下WebMvcConfigurer接口,SpringBoot2.0之前的版本是 WebMvcConfigurerAdapter类。WebMvcConfigurer接口这个使用很多个默认方法，如图<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-a8ae5bd5ddd44305.png" class="lozad"><br>这里讲一下主要的几个方法用处</p><ul><li>addResourceHandlers方法通过ResourceHandlers实现静态资源的地址映射</li><li>addViewControllers方法通过ViewController将一个请求转到一个页面</li><li>configureMessageConverters方法配置在请求返回时内容采用什么转换器进行转换</li><li>addCorsMappings方法配置CORS跨域</li><li>addInterceptors方法通过InterceptorRegistry添加拦截器</li></ul><h5 id="4-Controller及视图"><a href="#4-Controller及视图" class="headerlink" title="4.Controller及视图"></a>4.Controller及视图</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/login"</span>,method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user,ModelMap map)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"IndexController-用户名："</span>+user.getUsername()</span><br><span class="line">+<span class="string">",密码："</span>+user.getPassword());</span><br><span class="line">map.put(<span class="string">"username"</span>, user.getUsername());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图采用了Freemarker模板，只是简单的显示一下。</p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven如何构建项目</title>
      <link href="/post/2019/3/8/"/>
      <url>/post/2019/3/8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Maven是一个项目管理的综合工具。使用 Maven 给我们带来的最直接的好处，就是统一管理了jar 包及jar包之间依赖维护，为我们省去了到各个网站去下载所需的jar包。本篇文章主要讲讲如何用Maven去构建项目。</p><h3 id="一、命令行构建maven项目"><a href="#一、命令行构建maven项目" class="headerlink" title="一、命令行构建maven项目"></a>一、命令行构建maven项目</h3><ol><li>打开命令控制台,输入命令mvn archetype:generate</li><li>选择需要创建的模板，默认7（普通java项目），10（javaweb项目）<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-c7d6d1a6c58ff5d0.png" class="lozad"></li><li>输入groupId，artifactId，version三要素及package<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-9813a8f7b115cc04.png" class="lozad"></li><li>回车确认后，创建完毕</li></ol><p><strong>当然也可以一次性命令创建项目</strong></p><ul><li><p>创建java项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=&#123;project-packaging&#125; -DartifactId=&#123;project-name&#125; </span><br><span class="line">-DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</span><br></pre></td></tr></table></figure></li><li><p>创建简单web项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=&#123;project-packaging&#125; -DartifactId=&#123;project-name&#125; </span><br><span class="line">-DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</span><br></pre></td></tr></table></figure></li></ul><h3 id="二、Eclipse上构建maven项目"><a href="#二、Eclipse上构建maven项目" class="headerlink" title="二、Eclipse上构建maven项目"></a>二、Eclipse上构建maven项目</h3><p>一般较新版本的Eclipse都会带有Maven插件，如何没有可点击Help -&gt; Eclipse Marketplace，搜索maven关键字，安装如下插件<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-0c1a80cdca47700d.png" class="lozad"></p><ol><li>Maven环境配置：点击Window -&gt; Preferences-&gt;Maven<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-30e08fe8b7cfe75c.png" class="lozad"></li><li>New 菜单 Other.. -&gt; Maven -&gt; Maven Project </li><li>选择Create a simple project及Use default Workspace location<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-ad0ee254865cb361.png" class="lozad"></li><li>添加项目信息,Finish完成。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-760dee0d4e0843d1.png" class="lozad"></li></ol><h3 id="三、IDEA上构建maven项目"><a href="#三、IDEA上构建maven项目" class="headerlink" title="三、IDEA上构建maven项目"></a>三、IDEA上构建maven项目</h3><p>与在eclipse上类似，首先配置好本地的Maven，我这边直接放图了。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-10b8deab2b50decd.png" class="lozad"><br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-d57b1d3ea5ddbc4c.png" class="lozad"><br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-d012f54a42dfda09.png" class="lozad"></p><h3 id="四、pom-xml配置文件详解"><a href="#四、pom-xml配置文件详解" class="headerlink" title="四、pom.xml配置文件详解"></a>四、pom.xml配置文件详解</h3><p>以下列出了一些比较常用标签及说明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 模型版本。maven2.0必须是这样写，现在是maven2唯一支持的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 公司或者组织的唯一标志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testProject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目的版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打包类型，如pom,jar, maven-plugin, ejb, war, ear, rar, par，默认为jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--项目一些信息，如项目名，描述，项目地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>testProject<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>一个测试项目<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.test.com/ <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父pom配置，子pom可继承父pom的groupId，version --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设空值将始终从仓库中获取;</span></span><br><span class="line"><span class="comment">            查找顺序：relativePath元素中的地址–本地仓库–远程仓库</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--父pom中，包含的子模块配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span><span class="tag">&lt;<span class="name">module</span>&gt;</span>子模块<span class="tag">&lt;/<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目开发者列表 --&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目开发者的信息，列举了主要一些标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目开发者名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> xxxxxx<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目开发者email --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">email</span>&gt;</span> xxxxxx@163.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目开发者URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span> &gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目开发者所属机构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">organization</span>&gt;</span> <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--列出项目协议--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--license名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>MIT<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comments</span>&gt;</span> <span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">file.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">file.encoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commons.io.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">commons.io.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--dependencyManagement</span></span><br><span class="line"><span class="comment">          父pom可以用来统一管理子模块的依赖jar包；</span></span><br><span class="line"><span class="comment">          子pom可以用来引入父pom</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            ........</span><br><span class="line"><span class="comment">&lt;!--子pom通过非继承的方式来引入pom,可以多个;而parent的方式只能一个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>project_parent1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 定义项目的jar依赖关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--范围选择，默认compile：编译，运行，测试 有效</span></span><br><span class="line"><span class="comment">                  provided：编译，测试 有效，不含在打包中</span></span><br><span class="line"><span class="comment">                  test：测试 有效</span></span><br><span class="line"><span class="comment">                  runtime：运行，测试 有效</span></span><br><span class="line"><span class="comment">                  system：仓库之外的类库；编译，测试 有效</span></span><br><span class="line"><span class="comment">              --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>配合 scope=system时使用<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置依赖是否阻断传递，默认为false,项目可依赖quartz所依赖的jar，  </span></span><br><span class="line"><span class="comment">                          为true,则项目不依赖quartz所依赖的jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>false<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 排除依赖关系。禁止c3p0导入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--构建配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 产生的构件的文件名，默认值是$&#123;project.artifactId&#125;-$&#123;project.version&#125;。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 构建产生的所有文件存放的目录,默认为$&#123;basedir&#125;/target，即项目根目录下的target --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--插件列表--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--远程库配置，可能需要引入一些特殊jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--远程库地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--开启发布版本的下载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插件远程库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启发布版本的下载--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关闭快照的下载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖范围</strong></p><table><thead><tr><th>scope</th><th>编译</th><th>测试</th><th>运行</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>test</td><td></td><td>Y</td><td></td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td></td></tr><tr><td>runtime</td><td></td><td>Y</td><td>Y</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td></td></tr></tbody></table><p><strong>依赖传递性</strong><br>比如有a,b,c三个jar包或项目，a依赖b,b依赖c,而c对于a来说是传递性依赖。传递依赖受依赖范围限制。下表中第一列代表a对b的依赖，第一行代表b对c的依赖。则a对于c的依赖，为空则不依赖。</p><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th><th>runtime</th></tr></thead><tbody><tr><td>compile</td><td>compile</td><td></td><td></td><td>runtime</td></tr><tr><td>test</td><td>test</td><td></td><td></td><td>test</td></tr><tr><td>provided</td><td>provided</td><td></td><td>provided</td><td>provided</td></tr><tr><td>runtime</td><td>runtime</td><td></td><td></td><td>runtime</td></tr></tbody></table><h3 id="五、Maven打包命令"><a href="#五、Maven打包命令" class="headerlink" title="五、Maven打包命令"></a>五、Maven打包命令</h3><p>主要有三个打包命令mvn package、mvn install、mvn deploy。当然一般打包之前都会先清理一下。</p><ul><li>mvn clean package：完成了清理、项目编译、单元测试、打包功能。</li><li>mvn clean install：完成了清理、项目编译、单元测试、打包及布署到本地maven仓库功能。</li><li>mvn clean deploy：完成了清理、项目编译、单元测试、打包及布署到本地maven仓库和远程仓库功能。</li></ul><p><strong>参考资料</strong><br><a href="https://blog.csdn.net/u012152619/article/details/51485297" target="_blank" rel="noopener">pom.xml配置文件详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础教程及常见问题解决方法</title>
      <link href="/post/2019/3/7/"/>
      <url>/post/2019/3/7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="一、Git简介"><a href="#一、Git简介" class="headerlink" title="一、Git简介"></a>一、Git简介</h3><p>首先简单介绍一下Git。Git 是一个开源的分布式版本控制系统。那与传统的集中式，比如cvs,svn有什么区别呢?</p><ul><li>集中式顾名思义，集中存放在中央服务器。干活的时候，必须联网，首先要从中央服务器取得最新的版本。完了后，把自己的提交到中央服务器上。</li><li>分布式，没有正式的中央服务器，每个人的电脑上都是一个完整的版本库。干活的时候，不需要联网。各自干各自的活，完了后，提交到自己电脑的版本库中就行。而且比集中式安全的多，即使某个人的电脑坏了，可以从其他人的版本库拷贝一份。而集中式的中央服务器坏了，那就没法干活了。</li></ul><h3 id="二、Git基础命令"><a href="#二、Git基础命令" class="headerlink" title="二、Git基础命令"></a>二、Git基础命令</h3><h5 id="1-创建与获取"><a href="#1-创建与获取" class="headerlink" title="1.创建与获取"></a>1.创建与获取</h5><ul><li>初始化Git仓库。  git init</li><li>连接远程仓库。git remote add [远程库别名] [url]</li><li>克隆一个远程仓库。git clone [url]</li></ul><h5 id="2-暂存区、版本库"><a href="#2-暂存区、版本库" class="headerlink" title="2.暂存区、版本库"></a>2.暂存区、版本库</h5><ul><li>提交到暂存区。 git add</li><li>查看项目文件在工作目录与暂存区的状态。 git status -s </li><li>显示已写入暂存与已修改但尚未写入暂存的区别。git diff</li><li>提交到版本库。 git commit -m “说明”</li><li>删除暂存区与工作目录文件。git rm [文件名]</li><li>查看历史命令。git reflog</li><li>版本回退。git reset –hard [提交id]</li><li>查看提交历史。git log</li><li>工作区某个文件修改后，撤销修改。git checkout  [某个文件名]</li><li>某个文件修改后已提交到暂存区，撤销暂存区修改。git reset HEAD [某个文件名]</li></ul><h5 id="3-分支管理"><a href="#3-分支管理" class="headerlink" title="3.分支管理"></a>3.分支管理</h5><ul><li>列出分支。git branch</li><li>切换分支。git checkout [分支名]</li><li>删除分支。git branch -d [分支名]</li><li>强制删除分支。git branch -D [分支名]</li><li>删除远程分支。git push [远程库别名] –delete [分支名]</li><li>创建分支。git branch [分支名]</li><li>创建并切换到新分支。git checkout -b [分支名]</li><li>合并分支。git merge [分支名]</li><li>查看分支合并图。git log –graph</li></ul><h5 id="4-与远程库的操作"><a href="#4-与远程库的操作" class="headerlink" title="4.与远程库的操作"></a>4.与远程库的操作</h5><ul><li>把本地库推送到远程库。git push &lt;-u&gt; [远程库别名] [分支名(本地，远程同名)];<br>git push [远程库别名] [本地分支名]：[远程分支名]</li><li>拉取远程库并合并到本地库。git pull [远程库别名]  [分支名] </li><li>拉取远程库。git fetch</li><li>查看远程库地址。git remote –v </li><li>建立本地库分支和远程库分支的关联。git branch –set-upstream [分支名] [远程库别名]/[远程分支名]</li></ul><h5 id="5-标签管理"><a href="#5-标签管理" class="headerlink" title="5.标签管理"></a>5.标签管理</h5><ul><li>查看所有标签。git tag</li><li>当前提交打个标签。git tag [标签名]</li><li>历史提交打个标签。git tag [标签名] [历史提交id]</li><li>查看某个标签信息。git show [标签名]</li><li>删除标签。git tag -d [标签名]</li><li>删除远程库标签，要先删本地库。git push [远程库别名]:refs/tags/[标签名]</li><li>把标签推送到远程库。git push [远程库别名] [标签名]</li><li>多个本地标签一次性推送到远程库。git push [远程库别名] –tags</li></ul><h5 id="6-子模块管理"><a href="#6-子模块管理" class="headerlink" title="6.子模块管理"></a>6.子模块管理</h5><ul><li>原项目中增加子模块。git submodule add [子模块url]</li><li>克隆含有子模块的项目。(1)git clone [项目url] (2)进入子模块目录git submodule init初始化本地配置文件 (3)git submodule update检出数据</li></ul><h3 id="三、常见问题及解决方法"><a href="#三、常见问题及解决方法" class="headerlink" title="三、常见问题及解决方法"></a>三、常见问题及解决方法</h3><h5 id="1-git怎么在git-add-时忽略一些文件的提交"><a href="#1-git怎么在git-add-时忽略一些文件的提交" class="headerlink" title="1.git怎么在git add . 时忽略一些文件的提交"></a>1.git怎么在git add . 时忽略一些文件的提交</h5><p>在Git项目根目录中定义.gitignore文件。在.gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.log</span><br><span class="line">*.temp</span><br><span class="line">/target</span><br></pre></td></tr></table></figure><p>忽略.log .temp结尾的及根目录下的target文件夹下的文件。.gitignore注释用’#’, *表示匹配0个或多个任意字符，?表示匹配单个任意字符。当然还有更详细的优先级及匹配规则。这里就点到为止。</p><h5 id="2-远程仓库与本地仓库冲突"><a href="#2-远程仓库与本地仓库冲突" class="headerlink" title="2.远程仓库与本地仓库冲突"></a>2.远程仓库与本地仓库冲突</h5><p><strong>方法一</strong></p><ul><li>拉取到一个新分支。git fetch [远程库别名] [远程分支]:newBranch</li><li>比较新分支和本地分支的区别并修改冲突。git diff newBranch</li><li>分支合并。git merge newBranch [–allow-unrelated-histories]<blockquote><p>注意：其中–allow-unrelated-histories是可选项，当报错“refusing to merge unrelated histories”时加上该选项就可以进行merge。  在进行pull操作时如果也报这个错误也可以加上这个选项。</p></blockquote></li><li>提交。  git push </li><li>删除新分支。 git branch -d newBranch</li></ul><hr><p><strong>方法二</strong></p><ul><li>git stash 将本地代码stash到缓存。</li><li>git pull 将远程代码拉取到本地。</li><li>git stash pop 将缓存中的代码合到本地最新代码中。git stash pop默认将最近一次stash操作的缓存内容弹出。git stash apply只获取，不弹出。git stash pop stash@{Number}指定某次stath操作的缓存。</li><li>git stash show 显示stash合并到本地代码后，哪些文件会修改，以及修改的概述。</li><li>git stash clear清除所有缓存内容。 </li></ul><h5 id="3-在windows中操作git-reset-–hard-HEAD-报错"><a href="#3-在windows中操作git-reset-–hard-HEAD-报错" class="headerlink" title="3.在windows中操作git reset –hard HEAD^ 报错"></a>3.在windows中操作git reset –hard HEAD^ 报错</h5><p>因为^在window是特殊字符。使用git reset –hard HEAD~1或git reset –hard “HEAD^”。</p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编译与类加载机制</title>
      <link href="/post/2019/3/3/"/>
      <url>/post/2019/3/3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>不论是物理机还是虚拟机，大部分的程序代码从开始编译到最终转化成物理机的目标代码或虚拟机能执行的指令集之前，都会按照如下图所示的各个步骤进行：<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-b38a40fa2c44f544.png" class="lozad"><br>其中绿色的模块可以选择性实现。基于物理机、虚拟机等的语言，大多都遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法解析和语法解析处理，把源码转化为抽象语法树。</p><h4 id="1-javac编译"><a href="#1-javac编译" class="headerlink" title="1.javac编译"></a>1.javac编译</h4><p>javac 编译器将<em>.java文件编译成为</em>.class文件。这里的 javac 编译器称为前端编译器，其他的前端编译器还有诸如 Eclipse JDT 中的增量式编译器 ECJ 等。相对应的还有后端编译器，它在程序运行期间将字节码转变成机器码，如 HotSpot 虚拟机自带的 JIT编译器（分 Client 端和 Server 端）。另外，还有可能会碰到静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码。</p><h5 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h5><p>词法分析是将源代码的字符流转变为标记集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志 int 由三个字符构成，但是它只是一个标记，不可拆分。</p><p>语法分析是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如 bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。</p><h5 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h5><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，党对符号名进行地址分配时，符号表是地址分配的依据。</p><h5 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h5><p>语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析。</p><ul><li>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等。</li><li>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。</li></ul><h5 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h5><p>字节码生成是 javac 编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器方法和类构造器<clinit>()方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造方法，而是指我们自己重载的构造方法，如果代码中没有提供任何构造方法，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造方法，这个工作在填充符号表阶段就已经完成了）。</clinit></p><h4 id="2-JIT编译"><a href="#2-JIT编译" class="headerlink" title="2.JIT编译"></a>2.JIT编译</h4><p>Java 程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了 JIT 编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化。<br>HotSpot 虚拟机中内置了两个JIT编译器：Client Complier 和 Server Complier，分别用在客户端和服务端，目前主流的 HotSpot 虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。<br>运行过程中会被即时编译器编译的“热点代码”有两类：</p><ul><li>被多次调用的方法。</li><li>被多次调用的循环体。</li></ul><p>目前主要的热点 判定方式有以下两种：</p><ul><li><strong>基于采样的热点探测：</strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li><strong>基于计数器的热点探测：</strong>采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li></ul><p>HotSpot 虚拟机中使用的是基于计数器的热点探测方法，它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</p><p>方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。<br>回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。</p><h4 id="3-类加载机制"><a href="#3-类加载机制" class="headerlink" title="3.类加载机制"></a>3.类加载机制</h4><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。<br><img alt="类的生命周期" data-src="https://upload-images.jianshu.io/upload_images/18796269-35b57a0a04957533.png" class="lozad"><br>类的加载过程主要包含了加载、验证、准备、解析和初始化这 5 个阶段。如下：</p><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>加载过程完成以下三件事：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在堆中生成一个代表这个类的 Class 对象，作为对方法区中这些数据的访问入口。</li></ul><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。</p><ul><li>文件格式的验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li><li>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合 Java 语法规范的元数据信息。</li><li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li>符号引用验证：它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li></ul><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。<br><img alt="基本类型及引用类型初始值" data-src="https://upload-images.jianshu.io/upload_images/18796269-50e48921af08785e.jpg" class="lozad"></p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。<br>这里说一下符合引用于直接引用的区别：</p><ul><li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</li><li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。<br>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。</li><li>类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li><li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</li><li>类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</li><li>接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行了super类静态语句块"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行了父类静态语句块"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行了子类静态语句块"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        System.out.println(Child.m);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行了super类静态语句块</span><br><span class="line">执行了父类静态语句块</span><br><span class="line">33</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化是类加载过程的最后一步，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。初始化阶段是执行类构造器<clinit>() 方法的过程。<br><clinit>()执行规则：</clinit></clinit></p><ul><li><clinit>()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</clinit></li><li><clinit>()方法与类的构造方法不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。</clinit></li><li><clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></li><li>接口中不能使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样会生成<clinit>()方法。但是接口与类不同的是：执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></clinit></li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</clinit></clinit></clinit></clinit></li></ul><h4 id="4-类加载时机"><a href="#4-类加载时机" class="headerlink" title="4.类加载时机"></a>4.类加载时机</h4><ul><li>创建类的实例，也就是new一个对象</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（Class.forName(“”)）</li><li>初始化一个类的子类（会首先初始化子类的父类）</li><li>JVM启动时标明的启动类</li></ul><h4 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5.类加载器"></a>5.类加载器</h4><p>类加载器细致的可以划分为：</p><ul><li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <jre_home>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</jre_home></li><li>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <java_home>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</java_home></li><li>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li><li>自定义类加载器（Custom ClassLoader）如果有必要，我们还可以加入自定义的类加载器。因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件。</li></ul><h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。<br>这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-2beae46b1526b0f9.png" class="lozad"><br>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要。例如，类java.lang.Object 类存放在 rt.jar 之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这就保证了 Object 类在程序中的各种类加载器中都是同一个类。</p><p><strong>参考资料</strong><br>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.<br>《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java垃圾回收</title>
      <link href="/post/2019/3/2/"/>
      <url>/post/2019/3/2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>垃圾回收主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h4 id="1-判断一个对象是否可被回收"><a href="#1-判断一个对象是否可被回收" class="headerlink" title="1.判断一个对象是否可被回收"></a>1.判断一个对象是否可被回收</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。<br>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><h5 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h5><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。<br>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><p>实际上，在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法，或 finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。如果该对象被判定为有必要执行 finalize()方法，那么这个对象将会被放置在一个名为 F-Queue 队列中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行 finalize()方法。finalize()方法是对象逃脱死亡命运的最后一次机会（因为一个对象的 finalize()方法最多只会被系统自动调用一次），稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果要在 finalize()方法中成功拯救自己，只要在 finalize()方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</p><h4 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h4><h5 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h5><p>标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。<br>不足：标记和清除过程效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。</p><h5 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h5><p>该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>优点:不会产生内存碎片。<br>不足:需要移动大量对象，处理效率比较低。</p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。<br>不足：只使用了内存的一半。</p><h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p><h4 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3.垃圾收集器"></a>3.垃圾收集器</h4><p>垃圾收集器是内存回收算法的具体实现，Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别。Sun HotSpot 虚拟机包含了如下收集器：新生代收集器：Serial、ParNew、Parallel Scavenge；老年代收集器：Serial Old、Parallel Old、CMS；整堆收集器：G1；<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-c865732a666c4f9a.jpg" class="lozad"><br>两个收集器间有连线，表明它们可以搭配使用：<br>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</p><h5 id="并发垃圾收集和并行垃圾收集的区别"><a href="#并发垃圾收集和并行垃圾收集的区别" class="headerlink" title="并发垃圾收集和并行垃圾收集的区别"></a>并发垃圾收集和并行垃圾收集的区别</h5><ul><li>并行（Parallel）<br>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；<br>如ParNew、Parallel Scavenge、Parallel Old；</li><li>并发（Concurrent）</li></ul><p>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）；<br>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；<br>如CMS、G1（也有并行）；</p><h6 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h6><p>Serial（串行，单线程）垃圾收集器是最基本、发展历史最悠久的收集器； JDK1.3.1前是HotSpot新生代收集的唯一选择；<br>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。<br>设置参数 -XX:+UseSerialGC来显式的使用串行垃圾收集器。</p><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>它是 Serial 收集器的多线程版本。<br>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。<br>-XX:+UseConcMarkSweepGC：指定使用CMS后，会默认使用ParNew作为新生代收集器；<br> -XX:+UseParNewGC：强制指定使用ParNew；<br>-XX:ParallelGCThreads：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</p><h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>与 ParNew 一样是多线程收集器。<br>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。<br>-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间，大于0的毫秒数；<br>MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降；<br>因为可能导致垃圾收集发生得更频繁；<br>-XX:GCTimeRatio：设置垃圾收集时间占总时间的比率，0&lt;n&lt;100的整数；<br>GCTimeRatio相当于设置吞吐量大小；垃圾收集执行时间占应用程序执行时间的比例的计算方法是：1 / (1 + n)；默认值是1%–1/(1+99)，即n=99；<br>-XX:+UseAdptiveSizePolicy ： 开启这个参数后，就不用手工指定一些细节参数，如：<br>新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等；虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h5 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h5><p>Serial Old是 Serial收集器的老年代版本，也是给 Client 场景下的虚拟机使用。</p><h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本；JDK1.6中才开始提供。<br>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。<br>-XX:+UseParallelOldGC：指定使用Parallel Old收集器。</p><h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器。<br>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，采用多线程并行执行来提升效率，需要停顿。</li><li>并发清除：回收所有的垃圾对象，不需要停顿。<br>整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作； 所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行。<br>-XX:+UseConcMarkSweepGC：指定使用CMS收集器。</li></ul><p>CMS收集器3个明显的缺点</p><ul><li>对CPU资源非常敏感：并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。</li><li>无法处理浮动垃圾,可能出现”Concurrent Mode Failure”失败：浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用Serial Old 来替代 CMS。</li><li>产生大量内存碎片：往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1（Garbage-First），是JDK7-u4才推出商用的收集器，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。<br>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。<br>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。<br><img alt data-src="https://upload-images.jianshu.io/upload_images/18796269-ab7bf36b8226cddc.png" class="lozad"><br>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。<br>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>G1收集器运作过程<br>不计算维护Remembered Set的操作，可以分为4个步骤（与CMS较为相似）。</p><ul><li>初始标记（Initial Marking）：仅标记一下GC Roots能直接关联到的对象；<br>且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；需要停顿，但速度很快。</li><li>并发标记（Concurrent Marking）：进行GC Roots Tracing的过程；刚才产生的集合中标记出存活对象；耗时较长，但应用程序也在运行；并不能保证可以标记出所有的存活对象。</li><li>最终标记（Final Marking）：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；上一阶段对象的变化记录在线程的Remembered Set Log；这里把Remembered Set Log合并到Remembered Set中；需要停顿，且停顿时间比初始标记稍长，但远比并发标记短；采用多线程并行执行来提升效率。</li><li>筛选回收（Live Data Counting and Evacuation）：首先排序各个Region的回收价值和成本；然后根据用户期望的GC停顿时间来制定回收计划；最后按计划回收一些价值高的Region中垃圾对象； 回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；<br>可以并发进行，降低停顿时间，并增加吞吐量。</li></ul><h4 id="4-内存分配与回收策略"><a href="#4-内存分配与回收策略" class="headerlink" title="4.内存分配与回收策略"></a>4.内存分配与回收策略</h4><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><ul><li>对象优先在 Eden 分配<br>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</li><li>大对象直接进入老年代<br>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。<br>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</li></ul><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><ul><li>长期存活的对象进入老年代<br>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</li></ul><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><ul><li>动态对象年龄判定<br>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li><li>空间分配担保<br>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</li></ul><h5 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h5><ul><li>调用 System.gc()</li><li>老年代空间不足</li><li>空间分配担保失败</li><li>JDK 1.7 及以前版本的永久代空间不足</li><li>CMS收集时发生Concurrent Mode Failure错误</li></ul><p><strong>参考资料</strong><br>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.<br>《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版<br> <a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解 JVM(3)——7 种垃圾收集器</a><br> <a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">深入理解 JVM(2)——GC 算法与内存分配策略</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java虚拟机JVM内存组成结构</title>
      <link href="/post/2019/3/1/"/>
      <url>/post/2019/3/1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="1-JVM"><a href="#1-JVM" class="headerlink" title="1.JVM"></a>1.JVM</h4><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。<br>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机就是实现这一特点的关键。</p><h4 id="2-JVM内存模型"><a href="#2-JVM内存模型" class="headerlink" title="2.JVM内存模型"></a>2.JVM内存模型</h4><p><img alt="jvm内存结构" data-src="https://upload-images.jianshu.io/upload_images/18796269-abb0da036fa32fbe.png" class="lozad"></p><h5 id="PC程序计数器"><a href="#PC程序计数器" class="headerlink" title="PC程序计数器"></a>PC程序计数器</h5><p>记录正在执行的虚拟机字节码指令的地址，当线程在执行的是 Native 方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在 Java 虚拟机规范中么有规定任何 OOM（内存溢出：OutOfMemoryError）情况的区域。</p><h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h5><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<br>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M。</p><ul><li><strong>局部变量表</strong> 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）。</li><li><strong>操作数栈</strong>又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32 位数据类型所占的栈容量为 1,64 位数据类型所占的栈容量为 2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。</li><li><strong>动态连接</strong> 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</li><li><strong>方法返回地址</strong> 当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令。</li></ul><p>该区域可能抛出以下异常：</p><blockquote><p>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；<br>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</p></blockquote><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法栈与 Java 虚拟机栈类似，只不过本地方法栈是为本地方法服务。</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>所有对象都在这里分配内存，是垃圾收集的主要区域。堆分为新生代（Young Generation）和老年代（Old Generation）。新生代又可分为伊甸园区（Eden space）和两个幸存者区（Survivor pace）。<br>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>用于存放已被加载的类信息、常量、静态变量、即时编译器JIT编译后的代码等数据。对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。<br>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。<br>-XX:PermSize设置永久代初始大小，-XX:MaxPermSize设置永久代最大值。</p><blockquote><p>针对HotSpot 虚拟机<br>jdk1.6及之前： 有永久代， 方法区的数据存放在永久代中<br>jdk1.7：       有永久代，静态变量和常量池存放在堆中;其它剩下的存放在永久代中<br>jdk1.8及之后： 无永久代，静态变量和常量池存放在堆中；有元空间 ，储存元信息等数据</p></blockquote><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池是方法区的一部分。Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><ul><li><strong>字面量</strong> 指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的描述符、字段(成员变量)的名称和描述符、声明为final的成员变量。这些都在常量池的表中。</li><li><strong>符号引用</strong> 指指向表中的这些字面量的引用，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用。</li></ul><h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制。<br>在JDK1.4中新引入了NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><p><strong>参考资料</strong><br>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</p>]]></content>
      
      
      <categories>
          
          <category> 技术开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
